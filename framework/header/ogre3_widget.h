/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#ifndef MAGUS_OGRE_WIDGET_H
#define MAGUS_OGRE_WIDGET_H

#include <QWidget>
#include <QPaintEngine>
#include "OgreRoot.h"
#include "OgreRenderWindow.h"
#include "OgreString.h"
#include "OgreCamera.h"
#include "OgreColourValue.h"
#include "OgreItem.h"
#include "ogre3_cameraman.h"
#include "ogre_prereqs.h"
#include <QDockWidget>

namespace Magus
{
    static const Ogre::String AXIS_MATERIAL_NAME = "AMN0894587568";
    static const Ogre::String HIGHLIGHT_MATERIAL_NAME = "HLM1234567890";
    static const Ogre::String SKYBOX_WORKSPACE = "SkyPostprocessWorkspace";
    static const Ogre::String SKYBOX_MATERIAL_NAME = "SkyPostprocess";


    class OgreManager;

    /****************************************************************************
    QT Ogre Window for Ogre > V2.0
    ***************************************************************************/
    class QOgreWidget : public QWidget
    {
        Q_OBJECT

        public:
            QOgreWidget(QWidget* parent = 0);
            virtual ~QOgreWidget(void);
            QPaintEngine* paintEngine() const; // Turn off QTs paint engine for the Ogre widget.
            void updateOgre(float timeSinceLastFrame);
            void createRenderWindow(OgreManager* ogreManager);
            void createScene();
            Ogre::Item* getItem(void) {return mItem;}
            void setItem(Ogre::Item* item, Ogre::Item* itemRtt, const Ogre::Vector3& scale);
            Ogre::RenderWindow* getRenderWindow(void) {return mOgreRenderWindow;}
            Ogre::SceneManager* getSceneManager(void) {return mSceneManager;}
            const Ogre::Vector3& getItemScale(void);
            void setItemScale(const Ogre::Vector3& scale);
            void setDefaultDatablockItem(void);
            void setDefaultDatablockItemRtt(void); // Set the mItem to default
            void saveToFile(const Ogre::String& fileName);

            // Create item and use the current datablock of the previous item (if available)
            void createItem(const Ogre::String& meshName,
                            const Ogre::Vector3& scale);

            // Set the background colour
            void setBackgroundColour(const Ogre::ColourValue colour);

            void setRotateCameraMode (bool rotateCameraMode) {mRotateCameraMode = rotateCameraMode;}
            bool getRotateCameraMode (void) const {return mRotateCameraMode;}
            void enableLightItem(bool enabled); // Used to switch to ' light rotation mode'
            void createLightAxisMaterial(void); // Create the datablock of the light axis item
            void destroyLightAxisMaterial(void); // Destroy the datablock of the light axis item
            void updateSkyBoxMaterial(const Ogre::String& cubeMapBaseFileName); // Update the material of the skybox item
            void createHighlightMaterial(void); // Create the datablock used to highlight a subItem of mItem
            void destroyHighlightMaterial(void); // Destroy the datablock used to highlight a subItem of mItem
            void createUnlitDatablocksRtt(void); // Create datablocks of mItemRtt
            void destroyUnlitDatablocksRtt(void); // Destroy the datablocks of mItemRtt
            void resetHighlight(void); // Undo highlight of mItem (preserving its datablocks)
            void resetCamera(void); // Set position/orientation to default
            void setHoover(bool hoover); // Determines whether the subItems are highlighted when the mousecursor hoovers over them
            void setCurrentDatablockName(const Ogre::IdString& datablockName); // Only set the new datablock name; the new datablock is not set in an item/subitem
            const QVector<int>& getSubItemIndicesWithDatablock(const Ogre::IdString& datablockName); // Get the list of indices of subItems that have 'datablockName'
            void makeSnapshotOfItemMaterials(void); // Keep a map of all materials per subItem
            void restoreSnapshotOfItemMaterials(void); // Assign the material to each subItem
            Ogre::MeshPtr getCurrentMeshEnrichedWithItemDatablocksFullName(void); // Returns the mesh associated with mItem, but with the datablocknames of the mItem added to the mesh
            Ogre::MeshPtr getCurrentMesh(void); // Returns the mesh associated with mItem, but with the original materialnames in the mesh
            const QMap<unsigned short, Ogre::String>& getMaterialNamesFromCurrentMesh(void); // Returns map with index (of subMeash) and its materialname
            void setDatablockInSubItem(int index, const Ogre::IdString datablockName); // Set the datablock in the subitem, based on the id (datablockName) of the datablock
            void setDatablockInSubItems(const QVector<int>& indices, const Ogre::IdString& datablockName); // Set the datablock in the subitems, identified by indices
            void cleanup(void);
            void setRenderwindowDockWidget(QDockWidget* renderwindowDockWidget);
            void assignCurrentDatablock(void); // Set the current datablock in the item or subItem
            bool isSkyBoxVisible (void);
            void setSkyBoxVisible (bool visible);

        protected:
            Ogre::Root* mRoot;
            Ogre::RenderWindow* mOgreRenderWindow;
            Ogre::SceneManager* mSceneManager;
            Ogre::SceneManager* mSceneManagerTest;
            Ogre::Camera* mCamera;
            Ogre::ColourValue mBackground;
            Ogre::Real mTimeSinceLastFrame;
            CameraMan* mCameraManager;
            bool mSceneCreated;
            Ogre::Vector2 mAbsolute;
            Ogre::Vector2 mRelative;
            bool mSystemInitialized;
            Ogre::Item* mItem;
            Ogre::Item* mItemRtt;
            Ogre::Item* mLightAxisItem;
            Ogre::SceneNode* mSceneNode;
            Ogre::SceneNode* mSceneNodeRtt;
            Ogre::SceneNode* mLightNode;
            Ogre::SceneNode* mLightAxisNode;
            Ogre::CompositorWorkspace* mWorkspace;
            Ogre::CompositorWorkspace* mWorkspaceRtt;
            Ogre::CompositorWorkspace* mWorkspaceRttSkyBox;
            bool mRotateCameraMode;
            bool mShiftDown;
            bool mMouseDown;
            Ogre::Light* mLight;
            Ogre::TexturePtr mCustomRenderTexture;
            Ogre::RenderTexture* mRtt;
            Ogre::ColourValue mHelpColour;
            Ogre::String mRenderTextureName = "RenderTargetHlmsEditorTexture";
            int mLatestSubItemIndexHighlighted;
            Ogre::HlmsDatablock* mLatestSubItemDatablock;
            QSize mSize;
            Ogre::IdString mCurrentDatablockName;
            const size_t RTT_SIZE_X = 256;
            const size_t RTT_SIZE_Y = 144; // 9/16 x RTT_SIZE_X
            QMap <int, QVector3D> mColourMap;
            QMap <size_t, Ogre::String> mSnapshotDatablocks;
            bool mHoover;
            QMap<unsigned short, Ogre::String> helperIndicesAndNames;
            QVector<int> helperIndices;
            QDockWidget* mRenderwindowDockWidget;

            virtual void createCompositor();
            virtual void createCompositorRenderToTexture();
            void createSkyBoxCompositor();
            virtual void paintEvent(QPaintEvent *e);
            virtual void resizeEvent(QResizeEvent *e);
            virtual void keyPressEvent(QKeyEvent * ev);
            virtual void keyReleaseEvent(QKeyEvent * ev);
            virtual void mouseMoveEvent(QMouseEvent* e);
            //virtual void mouseWheelEvent(QWheelEvent* e);
            virtual void wheelEvent(QWheelEvent* e);
            virtual void mousePressEvent(QMouseEvent* e);
            virtual void mouseReleaseEvent(QMouseEvent* e);
            virtual void mouseDoubleClickEvent(QMouseEvent *event);
            GL_CONTEXT getCurrentGlContext(void);
            void rotateLight(Ogre::Vector2 relativeMouseMove);
            const Ogre::ColourValue& calculateIndexToColour(int index);
            int calculateColourToIndex(const Ogre::ColourValue& colourValue);
            const Ogre::ColourValue& getColourAtRenderToTexture(size_t x, size_t y);

            /* To highlight a subitem in on the screen, the following steps are performed
             * - Create a render texture and an additional workspace (createCompositorRenderToTexture)
             * - Create an additional Item (mItemRtt), based on the same mesh as the main Item (mItem) that is displayed on the screen
             * - For each subItem in mItemRtt, a specific colour (unlit material) is assigned, with name 0, 1, 2, 3, ...
             * - The colour of is associated with the subItem index (using a colourmap (mColourMap))
             * - mItemRtt is only rendered on the render texture and not on the screen.
             *   0 This is done by manually updating the render-texture workspace in the updateOgre function
             *   0 The scenenodes to which mItem and mItemRtt are attached are made visible/invisible
             * - The colour in the render texture is picked (getColourAtRenderToTexture); this is based on the mouse position on the render window
             * - The colour is translated to the index of the subItem (calculateColourToIndex), using the colourmap
             * - The subItem (based on the calculated index) of the mItem is highlighted with a green material (HIGHLIGHT_MATERIAL_NAME)
             */
            void highlightSubItem(Ogre::Vector2 mousePos);
            void setHighlightDatablockToSubItem(int index);
            void setColourToDatablockOfSubItem(int index, const Ogre::ColourValue& colour);
            const Ogre::ColourValue& getColourOfDatablockOfSubItem(int index);

            Ogre::HlmsDatablock* getDatablockByFullName(const Ogre::String& fullName);
    };
}

//****************************************************************************/
#endif // MAGUS_OGRE_WIDGET_H
