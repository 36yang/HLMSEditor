/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include "ogre3_widget.h"
#include "ogre3_renderman.h"
#include "Compositor/OgreCompositorManager2.h"
#include "Compositor/OgreCompositorNodeDef.h"
#include "Compositor/OgreCompositorWorkspace.h"
#include "Compositor/Pass/OgreCompositorPassDef.h"
#include "Compositor/Pass/PassClear/OgreCompositorPassClearDef.h"
#include "OgreRenderSystem.h"
#include "OgreHardwarePixelBuffer.h"
#include "OgreCommon.h"
#include "OgreTextureManager.h"
#include "OgreTimer.h"
#include "OgreHlmsManager.h"
#include "OgreHlmsPbs.h"
#include "OgreHlmsPbsDatablock.h"
#include "OgreHlmsUnlit.h"
#include "OgreHlmsUnlitDatablock.h"
#include "OgreMesh2.h"
#include "OgreSubMesh2.h"
#include "constants.h"

namespace Magus
{
    //****************************************************************************/
    QOgreWidget::QOgreWidget(QWidget* parent) :
        QWidget(parent),
        mRoot(0),
        mWorkspace(0),
        mWorkspaceRtt(0),
        mRtt(0),
        mOgreRenderWindow(0),
        mCamera(0),
        mCameraManager(0),
        mTimeSinceLastFrame (0.0f),
        mItem(0),
        mItemRtt(0),
        mLightAxisItem(0),
        mLight(0),
        mSceneNode(0),
        mSceneNodeRtt(0),
        mLightNode(0),
        mLightAxisNode(0),
        mSceneCreated(false),
        mSystemInitialized(false),
        mRotateCameraMode(true),
        mShiftDown(false),
        mMouseDown(false),
        mLatestSubItemIndexHighlighted(-1),
        mLatestSubItemDatablock(0),
        mHoover(false)
    {
        mCurrentDatablockName = "";
        setAttribute(Qt::WA_OpaquePaintEvent);
        setAttribute(Qt::WA_PaintOnScreen);
        mSize = QSize(100, 100);
        resize(mSize);
        setFocusPolicy(Qt::StrongFocus);
        setMouseTracking(true);
        mBackground = Ogre::ColourValue(0.1f, 0.1f, 0.1f);
        mAbsolute = Ogre::Vector2::ZERO;
        mRelative = Ogre::Vector2::ZERO;
        mHelpColour = Ogre::ColourValue::Red;
        mCustomRenderTexture.setNull();
        mSnapshotDatablocks.clear();
        helperIndicesAndNames.clear();

        // Fill the colourmap

        // Index 0-9
        mColourMap[0] = QVector3D(0.1f, 0.0f, 0.0f);
        mColourMap[1] = QVector3D(0.2f, 0.0f, 0.0f);
        mColourMap[2] = QVector3D(0.3f, 0.0f, 0.0f);
        mColourMap[3] = QVector3D(0.4f, 0.0f, 0.0f);
        mColourMap[4] = QVector3D(0.5f, 0.0f, 0.0f);
        mColourMap[5] = QVector3D(0.6f, 0.0f, 0.0f);
        mColourMap[6] = QVector3D(0.7f, 0.0f, 0.0f);
        mColourMap[7] = QVector3D(0.8f, 0.0f, 0.0f);
        mColourMap[8] = QVector3D(0.9f, 0.0f, 0.0f);
        mColourMap[9] = QVector3D(1.0f, 0.0f, 0.0f);

        // Index 10-19
        mColourMap[10] = QVector3D(0.0f, 0.1f, 0.0f);
        mColourMap[11] = QVector3D(0.0f, 0.2f, 0.0f);
        mColourMap[12] = QVector3D(0.0f, 0.3f, 0.0f);
        mColourMap[13] = QVector3D(0.0f, 0.4f, 0.0f);
        mColourMap[14] = QVector3D(0.0f, 0.5f, 0.0f);
        mColourMap[15] = QVector3D(0.0f, 0.6f, 0.0f);
        mColourMap[16] = QVector3D(0.0f, 0.7f, 0.0f);
        mColourMap[17] = QVector3D(0.0f, 0.8f, 0.0f);
        mColourMap[18] = QVector3D(0.0f, 0.9f, 0.0f);
        mColourMap[19] = QVector3D(0.0f, 1.0f, 0.0f);

        // Index 20-29
        mColourMap[20] = QVector3D(0.0f, 0.0f, 0.1f);
        mColourMap[21] = QVector3D(0.0f, 0.0f, 0.2f);
        mColourMap[22] = QVector3D(0.0f, 0.0f, 0.3f);
        mColourMap[23] = QVector3D(0.0f, 0.0f, 0.4f);
        mColourMap[24] = QVector3D(0.0f, 0.0f, 0.5f);
        mColourMap[25] = QVector3D(0.0f, 0.0f, 0.6f);
        mColourMap[26] = QVector3D(0.0f, 0.0f, 0.7f);
        mColourMap[27] = QVector3D(0.0f, 0.0f, 0.8f);
        mColourMap[28] = QVector3D(0.0f, 0.0f, 0.9f);
        mColourMap[29] = QVector3D(0.0f, 0.0f, 1.0f);

        // Index 30-39
        mColourMap[30] = QVector3D(0.1f, 0.1f, 0.0f);
        mColourMap[31] = QVector3D(0.2f, 0.2f, 0.0f);
        mColourMap[32] = QVector3D(0.3f, 0.3f, 0.0f);
        mColourMap[33] = QVector3D(0.4f, 0.4f, 0.0f);
        mColourMap[34] = QVector3D(0.5f, 0.5f, 0.0f);
        mColourMap[35] = QVector3D(0.6f, 0.6f, 0.0f);
        mColourMap[36] = QVector3D(0.7f, 0.7f, 0.0f);
        mColourMap[37] = QVector3D(0.8f, 0.8f, 0.0f);
        mColourMap[38] = QVector3D(0.9f, 0.9f, 0.0f);
        mColourMap[39] = QVector3D(1.0f, 1.0f, 0.0f);

        // Index 40-49
        mColourMap[40] = QVector3D(0.1f, 0.0f, 0.1f);
        mColourMap[41] = QVector3D(0.2f, 0.0f, 0.2f);
        mColourMap[42] = QVector3D(0.3f, 0.0f, 0.3f);
        mColourMap[43] = QVector3D(0.4f, 0.0f, 0.4f);
        mColourMap[44] = QVector3D(0.5f, 0.0f, 0.5f);
        mColourMap[45] = QVector3D(0.6f, 0.0f, 0.6f);
        mColourMap[46] = QVector3D(0.7f, 0.0f, 0.7f);
        mColourMap[47] = QVector3D(0.8f, 0.0f, 0.8f);
        mColourMap[48] = QVector3D(0.9f, 0.0f, 0.9f);
        mColourMap[49] = QVector3D(1.0f, 0.0f, 1.0f);

        // Index 50-59
        mColourMap[50] = QVector3D(0.0f, 0.1f, 0.1f);
        mColourMap[51] = QVector3D(0.0f, 0.2f, 0.2f);
        mColourMap[52] = QVector3D(0.0f, 0.3f, 0.3f);
        mColourMap[53] = QVector3D(0.0f, 0.4f, 0.4f);
        mColourMap[54] = QVector3D(0.0f, 0.5f, 0.5f);
        mColourMap[55] = QVector3D(0.0f, 0.6f, 0.6f);
        mColourMap[56] = QVector3D(0.0f, 0.7f, 0.7f);
        mColourMap[57] = QVector3D(0.0f, 0.8f, 0.8f);
        mColourMap[58] = QVector3D(0.0f, 0.9f, 0.9f);
        mColourMap[59] = QVector3D(0.0f, 1.0f, 1.0f);
}

    //****************************************************************************/
    QOgreWidget::~QOgreWidget()
    {
        // Cannot destroy the render texture here, because that would be too late (Ogre root is already deleted)
    }

    //****************************************************************************/
    void QOgreWidget::cleanup(void)
    {
        Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
        compositorManager->removeAllWorkspaceDefinitions();
        mWorkspaceRtt = 0;
        mWorkspace = 0;

        mCustomRenderTexture->unload();
        Ogre::TextureManager::getSingleton().unload(mRenderTextureName);
        Ogre::TextureManager::getSingleton().remove(mRenderTextureName);
        mCustomRenderTexture.setNull();
    }

    //****************************************************************************/
    HGLRC QOgreWidget::getCurrentGlContext(void)
    {
        #if defined(Q_OS_WIN)
            return wglGetCurrentContext(); // Windows
        #else
            return glXGetCurrentContext(); // Linux
        #endif

        return 0;
    }

    //****************************************************************************/
    void QOgreWidget::createRenderWindow(OgreManager* ogreManager)
    {
        if (!ogreManager)
            OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "No Ogre Manager available", "QOgreWidget::createRenderWindow");

        Ogre::Root* root = ogreManager->getOgreRoot();
        if (!root)
            OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "No Ogre Root available", "QOgreWidget::createRenderWindow");

        // Get rendersystem and assign window handle
        mRoot = root;
        Ogre::NameValuePairList parameters;

        // Reuse the glContext if available
        HGLRC glContext = 0;
        if (ogreManager->isRenderSystemGL())
        {
            parameters["currentGLContext"] = Ogre::String("false");
            glContext = ogreManager->getGlContext();
            if (glContext)
            {
                parameters["externalGLContext"] = Ogre::StringConverter::toString( (size_t)(glContext) );
                parameters["vsync"] = "No";
            }
        }

        #if defined(Q_OS_MAC) || defined(Q_OS_WIN)
            Ogre::String windowHandle = Ogre::StringConverter::toString((size_t)(this->winId()));
            parameters["externalWindowHandle"] = windowHandle;
            parameters["parentWindowHandle"] = windowHandle;
        #else
            Ogre::String windowHandle = Ogre::StringConverter::toString((unsigned long)(this->winId()));
            parameters["externalWindowHandle"] = windowHandle;
            parameters["parentWindowHandle"] = windowHandle;
        #endif

        #if defined(Q_OS_MAC)
            parameters["macAPI"] = "cocoa";
            parameters["macAPICocoaUseNSView"] = "true";
        #endif

        mOgreRenderWindow = mRoot->createRenderWindow(Ogre::StringConverter::toString(mRoot->getTimer()->getMicroseconds()),
                                                      this->width(),
                                                      this->height(),
                                                      false,
                                                      &parameters);
        mOgreRenderWindow->setVisible(true);

        // Determine whether the GL context can be reused
        if (ogreManager->isRenderSystemGL() && !glContext)
        {
            // Store the glContext in the ogre manager
            glContext = getCurrentGlContext();
            ogreManager->setGlContext(glContext);
        }

        // Create scene manager
        const size_t numThreads = std::max<int>(1, Ogre::PlatformInformation::getNumLogicalCores());
        Ogre::InstancingThreadedCullingMethod threadedCullingMethod = (numThreads > 1) ? Ogre::INSTANCING_CULLING_THREADED : Ogre::INSTANCING_CULLING_SINGLETHREAD;
        mSceneManager = mRoot->createSceneManager(Ogre::ST_GENERIC, numThreads, threadedCullingMethod);
        mSceneManager->getRenderQueue()->setRenderQueueMode(1, Ogre::RenderQueue::FAST);
        mSceneManager->getRenderQueue()->setRenderQueueMode(2, Ogre::RenderQueue::FAST);
        mSceneManager->setShadowDirectionalLightExtrusionDistance( 500.0f );
        mSceneManager->setShadowFarDistance( 500.0f );

        // Create camera
        mCamera = mSceneManager->createCamera("MainCamera");
        mCamera->setAspectRatio(Ogre::Real(mOgreRenderWindow->getWidth()) / Ogre::Real(mOgreRenderWindow->getHeight()));
        mCameraManager = new CameraMan(mCamera);

        // Create the compositor
        createCompositor();

        // Create the compositor RTT
        createCompositorRenderToTexture();
    }

    //****************************************************************************/
    void QOgreWidget::createScene()
    {
        // Create the node and attach the entity
        mSceneNode = mSceneManager->getRootSceneNode( Ogre::SCENE_DYNAMIC )->createChildSceneNode( Ogre::SCENE_DYNAMIC );
        mSceneNodeRtt = mSceneNode->createChildSceneNode( Ogre::SCENE_DYNAMIC );
        mSceneNode->setPosition(0.0, 0.0, 0.0);
        mSceneNodeRtt->setPosition(0.0, 0.0, 0.0);
        mCameraManager->setTarget(mSceneNode);

        // Create an item
        Ogre::Vector3 scale(25.0f, 25.0f, 25.0f);
        createItem ("cube.mesh", scale);

        // Remove the datablock currently set on this item
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );

        setDefaultDatablockItem();

        if (hlmsPbs->getDatablock(DATABLOCK_DEBUG_CUBE))
            hlmsPbs->destroyDatablock(DATABLOCK_DEBUG_CUBE);

        // Create light
        mLight = mSceneManager->createLight();
        mLightNode = mCameraManager->mCameraNode->createChildSceneNode(Ogre::SCENE_DYNAMIC);
        mLightNode->attachObject( mLight );
        mLight->setPowerScale( Ogre::Math::PI ); // Since we don't do HDR, counter the PBS' division by PI
        mLight->setType( Ogre::Light::LT_DIRECTIONAL );
        mLight->setDiffuseColour( Ogre::ColourValue::White );
        mLight->setSpecularColour( Ogre::ColourValue::White );
        mLight->setDirection(Ogre::Vector3(0, 1, 0));

        // Light axis node
        mLightAxisNode = mCameraManager->mCameraNode->createChildSceneNode(Ogre::SCENE_DYNAMIC);
        mLightAxisNode->setPosition(mCamera->getPosition() + Ogre::Vector3(0, -27, -100));
        mLightAxisItem = mSceneManager->createItem("axis.mesh",
                                                   Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                                                   Ogre::SCENE_DYNAMIC );
        mLightAxisItem->setRenderQueueGroup(2);
        mLightAxisNode->attachObject(mLightAxisItem);
        mLightAxisNode->setScale(Ogre::Vector3(0.12f, 0.12f, 0.12f));
        createLightAxisMaterial();
        mLightAxisItem->setVisible(false);
        createHighlightMaterial();

        // Put some light at the bottom, so the materials are not completely dark
        mSceneManager->setAmbientLight( Ogre::ColourValue::White,
                                        Ogre::ColourValue::White,
                                        Ogre::Vector3( 0, 1, 0 ).normalisedCopy());

        resetCamera();
        mSystemInitialized = true;
    }

    //****************************************************************************/
    void QOgreWidget::createLightAxisMaterial(void)
    {
        try
        {
            Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
            Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );
            Ogre::HlmsDatablock* datablock = hlmsPbs->getDatablock(AXIS_MATERIAL_NAME);

            // Return  if the datablock already exists
            if (datablock)
                return;

            // Create a Pbs datablock
            Ogre::HlmsMacroblock macroblock;
            macroblock.mDepthCheck = false;
            macroblock.mDepthWrite = false;
            Ogre::HlmsPbsDatablock*datablockPbs = static_cast<Ogre::HlmsPbsDatablock*>(
                        hlmsPbs->createDatablock( AXIS_MATERIAL_NAME,
                                                  AXIS_MATERIAL_NAME,
                                                  macroblock,
                                                  Ogre::HlmsBlendblock(),
                                                  Ogre::HlmsParamVec()));
            datablockPbs->setDiffuse(Ogre::Vector3(1, 0, 0));
            mLightAxisItem->setDatablock(AXIS_MATERIAL_NAME);
        }
        catch (Ogre::Exception e){}
    }

    //****************************************************************************/
    void QOgreWidget::destroyLightAxisMaterial(void)
    {
        try
        {
            mLightAxisItem->setDatablock(DEFAULT_DATABLOCK_NAME);
            Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
            Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );
            Ogre::HlmsDatablock* datablock = hlmsPbs->getDatablock(AXIS_MATERIAL_NAME);
            if (datablock && datablock->getLinkedRenderables().size() == 0)
                hlmsPbs->destroyDatablock(AXIS_MATERIAL_NAME);
        }
        catch (Ogre::Exception e){}
    }

    //****************************************************************************/
    void QOgreWidget::createHighlightMaterial(void)
    {
        // The highlight material is used for mItem
        try
        {
            // Create a Pbs datablock
            Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
            Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );
            Ogre::HlmsMacroblock macroblock;
            macroblock.mDepthCheck = true;
            macroblock.mDepthWrite = true;
            Ogre::HlmsPbsDatablock* datablock = static_cast<Ogre::HlmsPbsDatablock*>(
                        hlmsPbs->createDatablock( HIGHLIGHT_MATERIAL_NAME,
                                                  HIGHLIGHT_MATERIAL_NAME,
                                                  macroblock,
                                                  Ogre::HlmsBlendblock(),
                                                  Ogre::HlmsParamVec()));
            datablock->setDiffuse(Ogre::Vector3(0.0f, 1.0f, 0.0f));
            datablock->setSpecular(Ogre::Vector3(0.0f, 1.0f, 0.0f));
        }
        catch (Ogre::Exception e){}
    }

    //****************************************************************************/
    void QOgreWidget::destroyHighlightMaterial(void)
    {
        resetHighlight();
        try
        {
            Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
            Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );
            if (hlmsPbs->getDatablock(HIGHLIGHT_MATERIAL_NAME))
                hlmsPbs->destroyDatablock(HIGHLIGHT_MATERIAL_NAME);
        }
        catch (Ogre::Exception e){}
    }

    //****************************************************************************/
    void QOgreWidget::createItem(const Ogre::String& meshName, const Ogre::Vector3& scale)
    {
        try
        {
            Ogre::String datablockName = "";

            // Delete the old item if available
            if (mItem)
            {
                datablockName = *(mItem->getSubItem(0)->getDatablock()->getFullName());
                setDefaultDatablockItem();
                mSceneNode->detachAllObjects();
                mSceneManager->destroyItem(mItem);
            }

            // Create a new item
            mItem = mSceneManager->createItem(meshName,
                                              Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                                              Ogre::SCENE_DYNAMIC );
            mSceneNode->attachObject(mItem);
            mSceneNode->setScale(scale);
            mItem->setRenderQueueGroup(1);

            // Delete the old itemRtt if available
            if (mItemRtt)
            {
                destroyUnlitDatablocksRtt();
                mSceneNodeRtt->detachAllObjects();
                mSceneManager->destroyItem(mItemRtt);
            }

            // Create a new itemRtt
            mItemRtt = mSceneManager->createItem(meshName,
                                                 Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                                                 Ogre::SCENE_DYNAMIC );

            mSceneNodeRtt->attachObject(mItemRtt);
            createUnlitDatablocksRtt();
            mItemRtt->setRenderQueueGroup(1);
        }

        catch (Ogre::Exception e)
        {
        }
    }

    //****************************************************************************/
    void QOgreWidget::setItem(Ogre::Item* item, Ogre::Item* itemRtt, const Ogre::Vector3& scale)
    {
        Ogre::String datablockName = "";

        // Delete the old item if available
        if (mItem)
        {
            datablockName = *(mItem->getSubItem(0)->getDatablock()->getFullName());
            setDefaultDatablockItem();
            mSceneNode->detachAllObjects();
            mSceneManager->destroyItem(mItem);
        }

        // Set the new item
        mItem = item;
        mSceneNode->attachObject(mItem);
        mSceneNode->setScale(scale);
        mItem->setRenderQueueGroup(1);

        // Delete the old itemRtt if available
        if (mItemRtt)
        {
            destroyUnlitDatablocksRtt();
            mSceneNodeRtt->detachAllObjects();
            mSceneManager->destroyItem(mItemRtt);
        }

        // Set the new itemRtt
        mItemRtt = itemRtt;
        mSceneNodeRtt->attachObject(mItemRtt);
        createUnlitDatablocksRtt();
        mItemRtt->setRenderQueueGroup(1);
    }

    //****************************************************************************/
    void QOgreWidget::setDefaultDatablockItem(void)
    {
        // If one of the subItems was highlighted, restore it
        resetHighlight();

        // Set the default datablock
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
        Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));

        bool success = false;
        try
        {
            mItem->setDatablock(hlmsPbs->getDefaultDatablock()->getName());
            success = true;
        }
        catch (Ogre::Exception e) {}
        if (!success)
        {
            try
            {
                mItem->setDatablock(DEFAULT_DATABLOCK_NAME);
                success = true;
            }
            catch (Ogre::Exception e) {}
        }
        if (!success)
        {
            try
            {
                mItem->setDatablock(hlmsUnlit->getDefaultDatablock()->getName());
            }
            catch (Ogre::Exception e) {}
        }
    }

    //****************************************************************************/
    void QOgreWidget::setDefaultDatablockItemRtt(void)
    {
        resetHighlight();
        Ogre::HlmsDatablock* itemRttDatablock = mItemRtt->getSubItem(0)->getDatablock();
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
        Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));

        if (itemRttDatablock != hlmsUnlit->getDefaultDatablock())
            mItemRtt->setDatablock(hlmsUnlit->getDefaultDatablock()->getName());
        else
            if (itemRttDatablock != hlmsPbs->getDefaultDatablock())
                mItemRtt->setDatablock(hlmsPbs->getDefaultDatablock()->getName());
            else
                mItemRtt->setDatablock(DEFAULT_DATABLOCK_NAME);
    }

    //****************************************************************************/
    void QOgreWidget::createUnlitDatablocksRtt(void)
    {
        // Iterate through the subItems of mItemRtt and assign a colourvalue that corresponds with the subItem index
        // Set an unlit datablock with that colour
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT) );
        Ogre::HlmsMacroblock macroblock;
        Ogre::HlmsBlendblock blendblock;
        Ogre::ColourValue colour;
        Ogre::String datablockName;

        // Create a new datablock
        size_t numSubItems = mItemRtt->getNumSubItems();
        Ogre::SubItem* subItem;
        for (size_t i = 0; i < numSubItems; ++i)
        {
            subItem = mItemRtt->getSubItem(i);
            datablockName = Ogre::StringConverter::toString(i);
            Ogre::HlmsUnlitDatablock* datablock = static_cast<Ogre::HlmsUnlitDatablock*>(
                        hlmsUnlit->createDatablock( datablockName,
                                                    datablockName,
                                                    macroblock,
                                                    blendblock,
                                                    Ogre::HlmsParamVec()));
            colour = calculateIndexToColour(i);
            datablock->setUseColour(true);
            datablock->setColour(colour);
            subItem->setDatablock(datablockName);
        }
    }

    //****************************************************************************/
    void QOgreWidget::destroyUnlitDatablocksRtt(void)
    {
        // Detach all datablocks from mItemRtt
        setDefaultDatablockItemRtt();

        // Destroy all unlit materials; assume they are not attached anymore
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));
        size_t numSubItems = mItemRtt->getNumSubItems();
        for (size_t i = 0; i < numSubItems; ++i)
        {
            hlmsUnlit->destroyDatablock(Ogre::StringConverter::toString(i));
        }
    }

    //****************************************************************************/
    const Ogre::ColourValue& QOgreWidget::calculateIndexToColour(int index)
    {
        QVector3D v = mColourMap[index];
        mHelpColour.r = v.x();
        mHelpColour.g = v.y();
        mHelpColour.b = v.z();
        return mHelpColour;
    }

    //****************************************************************************/
    int QOgreWidget::calculateColourToIndex(const Ogre::ColourValue& colourValue)
    {
        QVector3D v;
        int index = -1;
        QMap <int, QVector3D>::iterator it = mColourMap.begin();
        QMap <int, QVector3D>::iterator itEnd = mColourMap.end();
        while (it != itEnd)
        {
            v = it.value();
            index = it.key();
            if (qAbs(v.x() - colourValue.r) < 0.05f &&
                qAbs(v.y() - colourValue.g) < 0.05f &&
                qAbs(v.z() - colourValue.b) < 0.05f)
                return index;

            ++it;
        }

        return -1;
    }

    //****************************************************************************/
    void QOgreWidget::setBackgroundColour(const Ogre::ColourValue colour)
    {
        mBackground = colour;
        Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
        Ogre::CompositorManager2::CompositorNodeDefMap mNodeDefinitions = compositorManager->getNodeDefinitions();
        Ogre::CompositorManager2::CompositorNodeDefMap::const_iterator iter;
        Ogre::CompositorManager2::CompositorNodeDefMap::const_iterator iterStart = mNodeDefinitions.begin();
        Ogre::CompositorManager2::CompositorNodeDefMap::const_iterator iterEnd = mNodeDefinitions.end();
        Ogre::CompositorNodeDef* nodeDef;
        Ogre::CompositorTargetDef* targetDef;
        Ogre::CompositorPassDef* passDef;
        Ogre::CompositorPassClearDef* clearDef;
        for (iter = iterStart; iter != iterEnd; ++iter)
        {
            nodeDef = iter->second;
            if (nodeDef)
            {
                if (nodeDef->getNumTargetPasses() > 0)
                {
                    targetDef = nodeDef->getTargetPass( 0 );
                    Ogre::CompositorPassDefVec passDefs = targetDef->getCompositorPasses();
                    Ogre::CompositorPassDefVec::const_iterator iterPass;
                    Ogre::CompositorPassDefVec::const_iterator iterPassStart = passDefs.begin();
                    Ogre::CompositorPassDefVec::const_iterator iterPassEnd = passDefs.end();
                    for (iterPass = iterPassStart; iterPass != iterPassEnd; ++iterPass)
                    {
                        passDef = *iterPass;
                        if (Ogre::PASS_CLEAR == passDef->getType())
                        {
                            clearDef = static_cast<Ogre::CompositorPassClearDef*>( passDef );
                            clearDef->mColourValue = colour;
                        }
                    }
                }
            }
        }
    }

    //****************************************************************************/
    void QOgreWidget::createCompositor()
    {
        Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
        const Ogre::String workspaceName = Ogre::StringConverter::toString(mRoot->getTimer()->getMicroseconds());
        const Ogre::IdString workspaceNameHash = workspaceName;
        compositorManager->createBasicWorkspaceDef(workspaceName, mBackground);
        mWorkspace = compositorManager->addWorkspace(mSceneManager, mOgreRenderWindow, mCamera, workspaceNameHash, true);
    }

    //****************************************************************************/
    void QOgreWidget::updateOgre(Ogre::Real timeSinceLastFrame)
    {
        if (!mSceneCreated)
        {
            createScene();
            mSceneCreated = true;
        }

        mTimeSinceLastFrame = timeSinceLastFrame;

        // Repaint
        repaint();
        if (this->size() != this->parentWidget()->size())
        {
            resize(this->parentWidget()->size());
        }

        if (mWorkspaceRtt)
        {
            // Set the background colour to black, otherwise the colours in the rtt are not uniquely assigned to a subItem anymore
            Ogre::ColourValue c;
            bool toggleBackgroundColour = mBackground != Ogre::ColourValue::Black;
            if (toggleBackgroundColour)
            {
                c = mBackground;
                setBackgroundColour(Ogre::ColourValue::Black);
            }

            mSceneNode->setVisible(false);
            bool lightVisibility;
            if (mLightAxisItem)
            {
                lightVisibility = mLightAxisItem->getVisible();
                mLightAxisItem->setVisible(false);
            }
            mSceneNodeRtt->setVisible(true);
            mSceneManager->updateSceneGraph();

            // Update workspace: begin
            mWorkspaceRtt->_beginUpdate(true);
            mWorkspaceRtt->_update();
            mWorkspaceRtt->_endUpdate(true);
            // Update workspace: end

            // Reset the visibility
            mSceneNode->setVisible(true);
            mSceneNodeRtt->setVisible(false);
            if (mLightAxisItem)
                mLightAxisItem->setVisible(lightVisibility);

            if (toggleBackgroundColour)
                setBackgroundColour(c);
        }
    }

    //-------------------------------------------------------------------------------------
    QPaintEngine* QOgreWidget::paintEngine() const
    {
        // We don't want another paint engine to get in the way for our Ogre based paint engine.
        // So we return nothing.
        return 0;
    }

    //-------------------------------------------------------------------------------------
    void QOgreWidget::paintEvent(QPaintEvent *e)
    {
    }

    //-------------------------------------------------------------------------------------
    void QOgreWidget::resizeEvent(QResizeEvent *e)
    {
        if(e->isAccepted())
        {
            mSize = e->size();
            if(mCamera && mOgreRenderWindow)
            {
                mOgreRenderWindow->resize(mSize.width(), mSize.height());
                mOgreRenderWindow->windowMovedOrResized();
                Ogre::Real aspectRatio = Ogre::Real(mSize.width()) / Ogre::Real(mSize.height());
                mCamera->setAspectRatio(aspectRatio);
            }
        }
    }

    //****************************************************************************/
    void QOgreWidget::keyPressEvent(QKeyEvent * ev)
    {
        if(mSystemInitialized)
        {
            mCameraManager->injectKeyDown(ev);
            if(ev->key() == Qt::Key_Shift)
                mShiftDown = true;

            // Testcode to write the render-texture to a file
            if(ev->key() == Qt::Key_S)
                mRtt->writeContentsToFile("rtt.png");
        }
    }

    //****************************************************************************/
    void QOgreWidget::keyReleaseEvent(QKeyEvent * ev)
    {
        if(mSystemInitialized)
        {
            mCameraManager->injectKeyUp(ev);
            if(ev->key() == Qt::Key_Shift)
                mShiftDown = false;
        }
    }

    //****************************************************************************/
    void QOgreWidget::enableLightItem(bool enabled)
    {
        if (mLightAxisItem)
        {
            mRotateCameraMode = !enabled; // We want to rotate the light if enabled = true
            mLightAxisItem->setVisible(enabled);
        }
    }

    //****************************************************************************/
    void QOgreWidget::setHoover(bool hoover)
    {
        mHoover = hoover;
        resetHighlight();
    }

    //****************************************************************************/
    void QOgreWidget::mouseMoveEvent( QMouseEvent* e )
    {
        if(mSystemInitialized)
        {
            Ogre::Vector2 oldPos = mAbsolute;
            mAbsolute = Ogre::Vector2(e->pos().x(), e->pos().y());
            mRelative = mAbsolute - oldPos;
            if (mRotateCameraMode)
                mCameraManager->injectMouseMove(mRelative);
            else
                rotateLight(mRelative);

            // Determine over which subItem the mouse hoovers
            if (mHoover)
                highlightSubItem(mAbsolute);
        }
    }

    //****************************************************************************/
    void QOgreWidget::rotateLight(Ogre::Vector2 relativeMouseMove)
    {
        if (mMouseDown)
        {
            mLightAxisNode->roll(Ogre::Degree(relativeMouseMove.x * 0.25f));
            mLightAxisNode->pitch(Ogre::Degree(relativeMouseMove.y * 0.25f));
            mLight->setDirection(mLightAxisNode->getOrientation().yAxis()); // Light direction follows light axis
        }
    }

    //****************************************************************************/
    void QOgreWidget::wheelEvent(QWheelEvent *e)
    {
        if(mSystemInitialized)
        {
            mCameraManager->injectMouseWheel(e);
            mLightAxisNode->setPosition(mCamera->getPosition() + Ogre::Vector3(0, -27, -100));
        }
    }

    //****************************************************************************/
    void QOgreWidget::mousePressEvent( QMouseEvent* e )
    {
        if(mSystemInitialized)
        {
            mCameraManager->injectMouseDown(e);
            if (e->button() == Qt::MiddleButton || e->button() == Qt::LeftButton)
                mMouseDown = true;
        }
    }

    //****************************************************************************/
    void QOgreWidget::mouseReleaseEvent( QMouseEvent* e )
    {
        if(mSystemInitialized)
        {
            mCameraManager->injectMouseUp(e);
            if (e->button() == Qt::MiddleButton || e->button() == Qt::LeftButton)
                mMouseDown = false;
        }
    }

    //****************************************************************************/
    void QOgreWidget::mouseDoubleClickEvent(QMouseEvent *event)
    {
        if(mSystemInitialized)
        {
            int index = mLatestSubItemIndexHighlighted;
            if (index > -1)
                resetHighlight();

            if (mHoover)
            {
                if (index > -1)
                    mItem->getSubItem(index)->setDatablock(mCurrentDatablockName);
            }
            else
                mItem->setDatablock(mCurrentDatablockName);
        }
    }

    //****************************************************************************/
    const Ogre::Vector3& QOgreWidget::getItemScale(void)
    {
        if (mItem && mItem->getParentSceneNode())
            return mItem->getParentSceneNode()->getScale();
    }

    //****************************************************************************/
    void QOgreWidget::setItemScale(const Ogre::Vector3& scale)
    {
        if (mItem && mItem->getParentSceneNode())
            mItem->getParentSceneNode()->setScale(scale);
    }

    //****************************************************************************/
    void QOgreWidget::saveToFile(const Ogre::String& fileName)
    {
        mOgreRenderWindow->writeContentsToFile(fileName);
    }

    //****************************************************************************/
    void QOgreWidget::createCompositorRenderToTexture(void)
    {
        // Create a render-texture to determine on which subitem the mouse pointer is pointing at
        mCustomRenderTexture = Ogre::TextureManager::getSingleton().createManual(mRenderTextureName,
                                                                                 Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                                                                                 Ogre::TEX_TYPE_2D,
                                                                                 RTT_SIZE_X,
                                                                                 RTT_SIZE_Y,
                                                                                 1,
                                                                                 Ogre::PF_R8G8B8A8,
                                                                                 Ogre::TU_RENDERTARGET);
        mCustomRenderTexture->load();
        mRtt = mCustomRenderTexture->getBuffer(0)->getRenderTarget();
        Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
        const Ogre::String workspaceName = Ogre::StringConverter::toString(mRoot->getTimer()->getMicroseconds());
        const Ogre::IdString workspaceNameHash = workspaceName;
        compositorManager->createBasicWorkspaceDef(workspaceName, Ogre::ColourValue::Black);
        mWorkspaceRtt = compositorManager->addWorkspace(mSceneManager, (Ogre::RenderTarget*)mRtt, mCamera, workspaceNameHash, false);
    }

    //****************************************************************************/
    const Ogre::ColourValue& QOgreWidget::getColourAtRenderToTexture(size_t x, size_t y)
    {
        // Sometimes the mousecoordinates are beyond the renderwindow. To prevent crashes in
        // pixelbox.getColourAt the maximum values of the mousecoordinates are validated
        mHelpColour = Ogre::ColourValue::Black;
        if (x > RTT_SIZE_X || y > RTT_SIZE_Y)
            return mHelpColour;

        size_t formatSize = Ogre::PixelUtil::getNumElemBytes(Ogre::PF_R8G8B8A8);
        Ogre::uchar* data = OGRE_ALLOC_T(Ogre::uchar, RTT_SIZE_X * RTT_SIZE_Y * formatSize, Ogre::MEMCATEGORY_RENDERSYS);
        Ogre::PixelBox pixelbox (RTT_SIZE_X, RTT_SIZE_Y, 1, Ogre::PF_R8G8B8A8, data);
        mRtt->copyContentsToMemory(pixelbox, Ogre::RenderTarget::FB_AUTO);
        mHelpColour = pixelbox.getColourAt(x, y, 0);
        OGRE_FREE(data, Ogre::MEMCATEGORY_RENDERSYS);
        return mHelpColour;
    }

    //****************************************************************************/
    void QOgreWidget::highlightSubItem(Ogre::Vector2 mousePos)
    {
        size_t x = (mousePos.x / (float)mSize.width()) * RTT_SIZE_X;
        size_t y = ((mousePos.y) / (float)mSize.height()) * RTT_SIZE_Y;
        Ogre::ColourValue colour = getColourAtRenderToTexture (x, y); // Get the colour of the mouse position (from the render texture)
        int index = calculateColourToIndex (colour); // Get the index of the subitem, based on the colour at the mouse position

        // Determine whether index is out of bounds (because of the symplistic scalar to colour mapping algorithm)
        if (index >= 0 && index >= mItem->getNumSubItems())
            return;

        // Determine whether the mouse is still over the latest subitem
        if (index == mLatestSubItemIndexHighlighted)
            return;

        // Determine whether index is still on a subitem
        if (index < 0)
        {
            if (mLatestSubItemIndexHighlighted >= 0)
            {
                // The mouse is currently not pointing to any subitem, but was previously pointing to a subitem, so restore the material
                resetHighlight();
            }
            else
            {
                // The mouse is currently not pointing to any subitem and was previously also not pointing to a subitem
                return;
            }
        }
        else
        {
            if (mLatestSubItemIndexHighlighted >= 0)
            {
                // The mouse is pointing to a subitem and previously pointing to another subitem, so restore the material
                resetHighlight();
            }

            // Highlight the subItem
            mLatestSubItemIndexHighlighted = index;
            setHighlightDatablockToSubItem (index);
        }
    }

    //****************************************************************************/
    void QOgreWidget::setHighlightDatablockToSubItem(int index)
    {
        mLatestSubItemDatablock = mItem->getSubItem(index)->getDatablock();
        mItem->getSubItem(index)->setDatablock(HIGHLIGHT_MATERIAL_NAME);
    }

    //****************************************************************************/
    void QOgreWidget::resetHighlight(void)
    {
        if (!mItem || !mLatestSubItemDatablock)
            return;

        if (mLatestSubItemIndexHighlighted == -1)
            return;

        if (mLatestSubItemIndexHighlighted >= 0 && mLatestSubItemIndexHighlighted >= mItem->getNumSubItems())
            return;

        mItem->getSubItem(mLatestSubItemIndexHighlighted)->setDatablock(mLatestSubItemDatablock->getName());
        mLatestSubItemIndexHighlighted = -1;
        mLatestSubItemDatablock = 0;
    }

    //****************************************************************************/
    void QOgreWidget::resetCamera(void)
    {
        mCamera->setPosition( Ogre::Vector3( 0, 40, 145) );
        mCamera->lookAt( Ogre::Vector3( 0, 0, 0 ) );
        mCamera->getParentSceneNode()->setOrientation(Ogre::Quaternion::IDENTITY);
        mLightAxisNode->setPosition(mCamera->getPosition() + Ogre::Vector3(0, -27, -100));
        mLightAxisNode->setOrientation(Ogre::Quaternion::IDENTITY);
    }

    //****************************************************************************/
    void QOgreWidget::setCurrentDatablockName(const Ogre::IdString& datablockName)
    {
        mCurrentDatablockName = datablockName;
    }

    //****************************************************************************/
    const QVector<int>& QOgreWidget::getSubItemIndicesWithDatablock(const Ogre::IdString& datablockName)
    {
        helperIndices.clear();
        size_t numSubItems = mItem->getNumSubItems();
        Ogre::SubItem* subItem;
        Ogre::HlmsDatablock* datablock;

        for (size_t i = 0; i < numSubItems; ++i)
        {
            subItem = mItem->getSubItem(i);
            datablock = subItem->getDatablock();
            if (datablock->getName() == datablockName)
                helperIndices.append(i);
        }

        return helperIndices;
    }

    //****************************************************************************/
    void QOgreWidget::makeSnapshotOfItemMaterials(void)
    {
        mSnapshotDatablocks.clear();
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
        Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));
        size_t numSubItems = mItem->getNumSubItems();
        Ogre::SubItem* subItem;
        Ogre::HlmsDatablock* datablock;
        Ogre::String datablockFullName;

        for (size_t i = 0; i < numSubItems; ++i)
        {
            subItem = mItem->getSubItem(i);
            datablock = subItem->getDatablock();
            if (datablock)
            {
                datablockFullName = *datablock->getFullName();
                if (    datablock != hlmsPbs->getDefaultDatablock() &&
                        datablock != hlmsUnlit->getDefaultDatablock() &&
                        datablockFullName != DEFAULT_DATABLOCK_NAME &&
                        datablockFullName != Magus::AXIS_MATERIAL_NAME &&
                        datablockFullName != Magus::HIGHLIGHT_MATERIAL_NAME)
                {
                    mSnapshotDatablocks[i] = datablockFullName;
                    //Ogre::LogManager::getSingleton().logMessage("make snaphot: " +  datablockFullName); // DEBUG
                }
            }
        }
    }

    //****************************************************************************/
    void QOgreWidget::restoreSnapshotOfItemMaterials(void)
    {
        QMap <size_t, Ogre::String>::iterator it = mSnapshotDatablocks.begin();
        QMap <size_t, Ogre::String>::iterator itEnd = mSnapshotDatablocks.end();
        size_t index;
        Ogre::String datablockFullName;
        Ogre::HlmsDatablock* datablock;

        while (it != itEnd)
        {
            datablockFullName = it.value();
            index = it.key();
            datablock = getDatablockByFullName(datablockFullName);
            Ogre::SubItem* subItem;
            if (mItem && datablock)
            {
                subItem = mItem->getSubItem(index);
                if (subItem)
                {
                    try
                    {
                        Ogre::LogManager::getSingleton().logMessage("make snaphot: " +  *datablock->getFullName()); // DEBUG
                        subItem->setDatablock(datablock->getName());
                        //subItem->setDatablock(datablock);
                    }
                    catch (Ogre::Exception e){}
                }
                //Ogre::LogManager::getSingleton().logMessage("restore snaphot: " +  datablockFullName); // DEBUG
            }
            ++it;
        }
    }

    //****************************************************************************/
    Ogre::HlmsDatablock* QOgreWidget::getDatablockByFullName(const Ogre::String& fullName)
    {
        Ogre::HlmsManager* hlmsManager = mRoot->getHlmsManager();
        Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>(hlmsManager->getHlms(Ogre::HLMS_PBS));
        Ogre::HlmsPbs* hlmsUnlit = static_cast<Ogre::HlmsPbs*>(hlmsManager->getHlms(Ogre::HLMS_UNLIT));

        Ogre::Hlms::HlmsDatablockMap::const_iterator itorPbs = hlmsPbs->getDatablockMap().begin();
        Ogre::Hlms::HlmsDatablockMap::const_iterator endPbs = hlmsPbs->getDatablockMap().end();
        Ogre::HlmsDatablock* datablock;
        while (itorPbs != endPbs)
        {
            datablock = itorPbs->second.datablock;
            if (datablock && *datablock->getFullName() == fullName)
                return datablock;

            ++itorPbs;
        }

        Ogre::Hlms::HlmsDatablockMap::const_iterator itorUnlit = hlmsUnlit->getDatablockMap().begin();
        Ogre::Hlms::HlmsDatablockMap::const_iterator endUnlit = hlmsUnlit->getDatablockMap().end();
        while (itorUnlit != endUnlit)
        {
            datablock = itorUnlit->second.datablock;
            if (datablock && *datablock->getFullName() == fullName)
                return datablock;

            ++itorUnlit;
        }

        return 0;
    }


    //****************************************************************************/
    Ogre::MeshPtr QOgreWidget::getCurrentMeshEnrichedWithItemDatablocksFullName(void)
    {
        Ogre::MeshPtr mesh = mItem->getMesh();
        Ogre::Mesh* meshPtr = mesh.getPointer();
        size_t numSubItems = mItem->getNumSubItems();
        Ogre::SubItem* subItem;
        Ogre::HlmsDatablock* datablock;
        Ogre::String datablockFullName;

        for (size_t i = 0; i < numSubItems; ++i)
        {
            subItem = mItem->getSubItem(i);
            datablock = subItem->getDatablock();
            if (datablock)
            {
                datablockFullName = *datablock->getFullName();
                meshPtr->getSubMesh(i)->setMaterialName(datablockFullName);
            }
        }

        return mItem->getMesh();
    }

    //****************************************************************************/
    Ogre::MeshPtr QOgreWidget::getCurrentMesh(void)
    {
        return mItem->getMesh();
    }


    //****************************************************************************/
    const QMap<unsigned short, Ogre::String>& QOgreWidget::getMaterialNamesFromCurrentMesh(void)
    {
        // Iterate through the current mesh and return a map with materialnames
        helperIndicesAndNames.clear();
        if (mItem)
        {
            Ogre::MeshPtr mesh;
            Ogre::Mesh* meshPtr;
            Ogre::SubMesh* subMesh;
            size_t numSubMeshes;
            mesh = mItem->getMesh();
            meshPtr = mesh.getPointer();
            numSubMeshes= meshPtr->getNumSubMeshes();
            for (size_t i = 0; i < numSubMeshes; ++i)
            {
                subMesh = meshPtr->getSubMesh(i);
                helperIndicesAndNames[i] = subMesh->getMaterialName();
            }
        }

        return helperIndicesAndNames;
    }

    //****************************************************************************/
    void QOgreWidget::setDatablockInSubItem(int index, const Ogre::IdString datablockName)
    {
        if (mItem)
        {
            Ogre::SubItem* subItem = mItem->getSubItem(index);
            if (subItem)
                subItem->setDatablock(datablockName);
        }
    }

    //****************************************************************************/
    void QOgreWidget::setDatablockInSubItems(const QVector<int>& indices,
                                             const Ogre::IdString& datablockName)
    {
        int index;
        Ogre::SubItem* subItem;
        QVectorIterator<int> it(indices);
        while(it.hasNext())
        {
            index = it.next();
            subItem = mItem->getSubItem(index);
            subItem->setDatablock(datablockName);
        }

        mCurrentDatablockName = datablockName;
    }

}
