/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#ifndef __HLMS_UTILS_MANAGER_H__
#define __HLMS_UTILS_MANAGER_H__

#include "constants.h"
#include "OgreRoot.h"
#include "OgreHlmsManager.h"
#include "OgreHlmsPbsDatablock.h"
#include "rapidjson/document.h"

/****************************************************************************
 This class contains some Hlms utilities to make life easier. Note, that this
 class keeps state for certain functions, so if you uese these functions,
 beware not to delete the instance of this class.
 ***************************************************************************/
class HlmsUtilsManager
{
    public:

        struct DatablockStruct
        {
            Ogre::HlmsDatablock* datablock; // Pointer to datablock
            Ogre::String datablockFullName; // Full mame of the datablock
            Ogre::IdString datablockId;
            EditorHlmsTypes type; // Type of the datablock
            Ogre::String jsonFileName; // Json file that contains the description of the datablock
            QMap <unsigned short, Ogre::String> textureMap; // Contains the textures used in the datablock
        };

        // Constructor
        HlmsUtilsManager (void);

        // Destructor
        virtual ~HlmsUtilsManager (void);

        /* Load a datablock
         * - If the jsonFile is loaded, the first datablock found in the json file is returned
         * - If the datablock was already loaded (registered), the loaded datablock is returned
         * - If the json file could not be loaded, a 0 is returned
         * When makeSnaphot == true, the HlmsUtilsManager keeps track of every loaded datablock and
         * registers the name of the datablock, the type of the datablock and the reference to
         * the jsonFileName.
         */
        DatablockStruct loadDatablock(const QString& jsonFileName,
                                      bool makeSnaphot = true);

        /* Returns the latest loaded datablock
         */
        DatablockStruct getLatestRegisteredDatablock(void) {return mRegisteredDatablockStruct;}

        /* Returns a datablock
         * This function first searches in the registered datablocks. If nothing is found, it searches
         * real datablocks (in Ogre)
         */
        DatablockStruct getDatablock(const Ogre::IdString& datablockId);

        /* A snapshot is made of the datablocks managed by Ogre::HlmsManager
         */
        void makeSnapshotDatablocks(void);

        /* All datablocks from mRegisteredDatablocks are reloaded
         * This function is used when all datablocks are destroyed temporarily and have to be reloaded
         * again. This is the case for export or saving datablocks.
         */
        void reloadNonSpecialDatablocks(void);

        /* The snapshot (taken from the Ogre::HlmsManager) is compared with the datablocks from Ogre::HlmsManager
         * The first difference that is encountered is used to compare with mRegisteredDatablocks
         * mRegisteredDatablocks is used, because Ogre doesn't administer the json files and we want to
         * keep the relation between datablocks, textures and the json file.
         */
        DatablockStruct compareSnapshotWithRegisteredDatablocksAndAdminister(const QString& jsonFileName, const char* jsonChar);

        /* Destroy datablocks, depending on the arguments.
         * excludeSpecialDatablocks == true and excludeDatablockFullName == ""
         * - Exclude the default datablocks from destroying
         * - Exclude Axis and Highlight materials from destroying
         * - Exclude the unlit materials associated with the 'render-texture'  item from destroying (defined by 0, 1, 2, 3, ...)
         *
         * excludeSpecialDatablocks == true and excludeDatablockFullName is filled with a valid datablock name (full name)
         * - Exclude the default datablocks from destroying
         * - Exclude Axis and Highlight materials from destroying
         * - Exclude the unlit materials associated with the 'render-texture'  item  from destroying (defined by name 0, 1, 2, 3, ...)
         * - Exclude the datablock with the same name as 'excludeDatablockFullName' from destroying
         *
         * excludeSpecialDatablocks == false and excludeDatablockFullName == ""
         * - All datablocks are destroyed
         *
         * excludeSpecialDatablocks == false and excludeDatablockFullName is filled with a valid datablock name (full name)
         * - Exclude the datablock with the same name as 'excludeDatablockFullName' from destroying
         */
        void destroyDatablocks(bool excludeSpecialDatablocks = true,
                               bool keepVecRegisteredDatablock = false,
                               const Ogre::String& excludeDatablockFullName = "");


        /* Delete a particular datablock
         */
        void destroyDatablock(const Ogre::IdString& datablockId);

        /* Returns the datablock info of a given full name (datablockFullName)
         * If there is no datablock with this name, a default DatablockStruct is returned
         */
        DatablockStruct getDatablockStructOfFullName (const Ogre::String& datablockFullName);

        /* Returns a vector with all texturenames from the loaded Pbs/Unlit datablocks
         */
        void getTexturesFromRegisteredPbsDatablocks(std::vector<Ogre::String>* v);
        void getTexturesFromRegisteredUnlitDatablocks(std::vector<Ogre::String>* v);

        /* Returns the json file name of a datablock.
         * The name is only filled with a proper value in case the datablock was loaded/saved through a json file
         */
         const Ogre::String& searchJsonFileName (const Ogre::IdString& datablockId);

        /* Add a datablock to the registered datablocks registry (mRegisteredDatablocks). This is needed in cases where a datablock's properties are changed and
         * the name still refers to an item in the material browser
         */
         void addNewDatablockToRegisteredDatablocks (const Ogre::IdString& datablockId, const Ogre::String jsonFileName);

         /* Returns the base texture filename of a texture type from a given Pbs datablock.
          * The datablock MUST be a Pbs datablock.
          */
          const Ogre::String& getTextureFileNameOfPbs (const Ogre::IdString& datablockId, Ogre::PbsTextureTypes textureType);

    protected:
        bool isInRegisteredDatablocksVec (const Ogre::String& datablockFullName);

        /* Parse a json string and get the details (texture names) from the string. This function was
         * added because it is easier to retrieve texture names from the json file instead of  using
         * HlmsTextureManager::findAliasNamefindAliasName.
         * Unfortunalty, the json file gets parsed twice (first time by Ogre and second time by the
         * editor, but this is only as part of loading from disk, which is slow already.
         */
        bool parseJsonAndRetrieveDetails (DatablockStruct* datablockStruct, const char* jsonChar);

        // Parse a texturetype fragment of a pbs datablock
        void parsePbsTextureType (DatablockStruct* datablockStruct,
                                  const rapidjson::Value& textureTypeJson,
                                  const char* textureType,
                                  unsigned short index);

        // Parse a texture fragment of an unlit datablock
        void parseUnlitTexture (DatablockStruct* datablockStruct, const rapidjson::Value& textureJson);

        /* Enrich the textureMap in the datablockStruct (from the datablock)
         */
        void enrichTextureMapFromPbs(DatablockStruct* datablockStruct);
        void enrichTextureMapFromUnlit(DatablockStruct* datablockStruct);

    private:
        DatablockStruct helperDatablockStruct;
        QVector<DatablockStruct> mSnapshot;
        QVector<DatablockStruct> mRegisteredDatablocks;
        DatablockStruct mRegisteredDatablockStruct;
        Ogre::String helperString;
};

#endif
