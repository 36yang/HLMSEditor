/****************************************************************************
**
** Copyright (C) 2016 - 2017
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QCloseEvent>
#include <QMainWindow>
#include <QMenu>
#include <QAction>
#include <QMessageBox>
#include <QToolBar>
#include <QList>
#include "OgreDataStream.h"
#include "OgreMesh2.h"
#include "Ogre.h"
#include "renderwindow_dockwidget.h"
#include "properties_dockwidget.h"
#include "texture_dockwidget.h"
#include "nodeeditor_dockwidget.h"
#include "paint_dockwidget.h"
#include "brush_preset_dockwidget.h"
#include "paintlayer_dockwidget.h"
#include "central_dockwidget.h"
#include "material_browser_dialog.h"
#include "ogre3_renderman.h"
#include "hlms_editor_plugin.h"
#include "recent_file_action.h"
#include "hlms_utils_manager.h"
#include "paintlayer_manager.h"
#include "constants.h"

QT_BEGIN_NAMESPACE
QT_END_NAMESPACE

/****************************************************************************
 MainWindow is the main container window.
 Note, that most public function refer to materials as materials, while in the
 underlying functions and other class the name 'datablock' is used. They mean
 the same, but 'material' is also more of a concept than the actual implementatino
 ***************************************************************************/
class MainWindow : public QMainWindow
{
	Q_OBJECT

	public:
		MainWindow(void);
		~MainWindow(void);
        bool eventFilter(QObject* object, QEvent* event);
		void update(void);
		bool mIsClosing;
        PaintLayerManager mPaintLayerManager;

        // Public DockWidgets
        RenderwindowDockWidget* mRenderwindowDockWidget; // Make is public for easy access
        PropertiesDockWidget* mPropertiesDockWidget; // Make is public for easy access
        TextureDockWidget* mTextureDockWidget; // Make is public for easy access
        PaintDockWidget* mPaintDockWidget; // Make is public for easy access
        BrushPresetDockWidget* mBrushPresetDockWidget; // Make is public for easy access
        PaintLayerDockWidget* mPaintLayerDockWidget; // Make is public for easy access

        // Public functions
        Magus::OgreManager* getOgreManager(void) const {return mOgreManager;}
        void initCurrentMaterialFileName(void); // Set the name of the current json file to ""
        void getListOfResources(void); // Function to test which resources are loaded
        EditorHlmsTypes getCurrentDatablockType(void); // Returns the current hlms type
        void loadTextureBrowserCfg(void);
        void setCurrentDatablockIdAndNameStr(const Ogre::IdString& datablockId, const Ogre::String& nameStr);
        QVector<int> getSubItemIndicesWithDatablockAndReplaceWithDefault(const Ogre::IdString& datablockId); // Get list of indeces, which have datablock 'datablockId'
        void replaceCurrentDatablock(QVector<int> indices, Ogre::IdString datablockId); // Set the datablocks in the subItems, identified by 'indices'
        const Ogre::String& getCurrentDatablockNameStr (void) {return mCurrentDatablockNameStr;}
        const Ogre::IdString& getCurrentDatablockId (void) {return mCurrentDatablockId;}
        void notifyMaterialChanged (QtProperty* property); // To be called if the properties of a datablock are changed (which result in rebuilding the material)
        HlmsUtilsManager* getHlmsUtilsManager (void) {return mHlmsUtilsManager;}
        const Ogre::String& getTextureFileNameOfPbs(const Ogre::IdString& datablockId, Ogre::PbsTextureTypes textureType); // Returns the filename of a pbs texture type
        void notifyNodeDeleted (unsigned int nodeType); // Is called by the node editor if a node is deleted
        void notifyCopiedSamplerblockToClipboard (void); // Is called by the node editor if a samplerblock is put on the clipboard
        void notifyCopiedPbsDatablockToClipboard (void); // Is called by the node editor if a pbs datablock is put on the clipboard
        bool isSamplerClip(const QString& filename); // Returns true is a filename is a sampler clip
        bool isPbsClip(const QString& filename); // Returns true is a filename is a pbs clip
        void useFromClipboard (const QString& fileName); // Is called if something from the clipboard must be used
        void addResourceLocationFile (const QString& fileName);
        void addResourceLocationPath (const QString& path);
        void loadMaterialAndCreateNodeStructure(const QString jsonFileName); // Load the material and create the node structure (the material is not applied to the mesh (item))
        void applyCurrentMaterialToMesh(void); // Apply the material to the whole mItem (so also all subitems)

        // Public Paint functions
        PaintLayers* getPaintLayers(void); // Returns pointer to the paintlayers, managed by the PainLayerManager
        void setBrushInPaintLayer(const QString& name, const QString& baseName); // If a brush is selected, set the new brush in the PaintLayer
        void loadTextureGeneration (Ogre::PbsTextureTypes textureType, Ogre::ushort sequence); // Load a texture, based on the type and sequence (texture is blit to the GPU)

        // Public Delete material functions
        void deleteCurrentMaterial(void); // Delete the current material; takes into account that the material is still attached to an item
        void deleteMaterial(const Ogre::IdString& id); // Delete a datablock based on id; takes into account that the material is still attached to an item
        void deleteAllMaterials(void); // Delete all materials, but excludes the special materials used in the editor; takes into account that the material is still attached to an item

    protected:
        void saveResources(const QString& fileName, const QVector<Magus::QtResourceInfo*>& resources); // Save the content of a resource vector
        QMessageBox::StandardButton fileDoesNotExistsWarning(const QString& fileName);
        void newProjectName(void);
        void appendRecentMaterialToRecentlyUsed(const QString fileName); // Used for recent Material files in menu
        void appendRecentProjectToRecentlyUsed(const QString fileName); // Used for recent Project files in menu
        bool isMeshV1(const QString meshFileName);
        bool isMeshV2(const QString meshFileName);
        unsigned int getMeshVersion(const QString meshFileName);
        Ogre::MeshPtr convertMeshV1ToV2(const QString fileNameMeshV1);
        void saveV2Mesh(Ogre::MeshPtr v2MeshPtr, QString meshFileName);
        void detachMaterialsFromItem (void);
        void restoreMaterialsOfItem (void);
        void createSpecialDatablocks (void);
        void destroySpecialDatablocks(void);
        void setDatablocksFromMaterialBrowserInItem(void);
        const Ogre::String& getJsonFileNameFromMaterialBrowser(const Ogre::String& nameStr);
        void createActions(void);
        void createMenus(void);
        void createToolBars(void);
        void createStatusBar(void);
        void createDockWindows(void);
        void closeEvent(QCloseEvent* event);
        void loadMesh(const QString meshFileName);
        void loadProject(const QString& fileName);
         // Saves the current datablock; if validatePaintLayers is true, the validation whether there are paintlayers must still be done
        void saveDatablock(bool validatePaintLayers);
        bool continueEvenIfThereArePaintLayers(void); // Validate whether there are paintlayers (before saving the datablock)

        void loadMaterialBrowserCfg(void);
        void saveMaterialBrowserCfg(void);
        void loadRecentMaterialFilesCfg(void);
        void saveRecentMaterialFilesCfg(void);
        void loadRecentProjectFilesCfg(void);
        void saveRecentProjectFilesCfg(void);
        Ogre::DataStreamPtr openFile(Ogre::String source);
        void clearNamesAndRemovePaintLayers (void);
        void deleteTempPathRecursive(void);
        const QString& getStringPropertyFromReferenceMap (const std::string& propertyName, Ogre::HlmsEditorPluginData* data);

	private slots:
        void doNewProjectAction(void);
        void doNewPbsMaterialAction(void);
        void doNewUnlitMaterialAction(void);
        void doOpenProjectMenuAction(void);
        void doOpenDatablockMenuAction(void);
        void doOpenMeshMenuAction(void);
        void doSaveProjectMenuAction(void);
        void doSaveDatablockMenuAction(void);
        void doSaveAsProjectMenuAction(void);
        void doSaveAsDatablockMenuAction(void);
        void doSaveAsMeshMenuAction(void);
        void doMaterialSetMenuAction(void);
        void doMaterialBrowserOpenMenuAction(void);
        void doMaterialBrowserAddMenuAction(void);
        void doMaterialPresetMenuAction(void);
        void doMaterialClearMenuAction (void);
        void doQuitMenuAction(void);
        void doTextureBrowserImportMenuAction(void);
        void doTextureBrowserAddImageMenuAction(void);
        void doNewPaintingLayerMenuAction(void);
        void doEditPaintingLayerMenuAction(void);
        void doSelectedPaintingLayersMenuAction(void);
        void doConfigureMenuAction(void);
        void doResetWindowLayoutMenuAction(void);
        void handleTextureDoubleClicked(const QString& fileName, const QString& baseName);
        void handleCustomContextMenuItemSelected(const QString& menuItemText);
        void handleTextureMutationOccured(void);
        void saveTextureBrowserCfg(void);
        void doImport(Ogre::HlmsEditorPlugin* plugin);
        bool doImportOpenFileDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data);
        void doExport(Ogre::HlmsEditorPlugin* plugin);
        bool doExportOpenFileDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data);
        void doImportExportPropertiesDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data);
        void constructHlmsEditorPluginData(Ogre::HlmsEditorPluginData* data);
        void doRecentMaterialFileAction(const QString& fileName);
        void doRecentProjectFileAction(const QString& fileName);
        void doMaterialBrowserAccepted(const QString& fileName);
        void doMaterialBrowserRejected(void);
        void doMaterialBrowserClosed(void);

	private:
        bool mFirst;
        QString mTempString;
        Ogre::String mTempOgreString;
        MaterialBrowserDialog* mMaterialBrowser;
        QMenu* mFileMenu;
        QMenu* mMaterialMenu;
        QMenu* mTextureMenu;
        QMenu* mWindowMenu;
        QMenu* mRecentMaterialsFilesMenu;
        QMenu* mRecentProjectFilesMenu;
        QAction* mNewProjectAction;
        QAction* mNewPbsMaterialAction;
        QAction* mNewUnlitMaterialAction;
        QAction* mOpenProjectMenuAction;
        QAction* mOpenDatablockMenuAction;
        QAction* mOpenMeshMenuAction;
        QAction* mSaveProjectMenuAction;
        QAction* mSaveDatablockMenuAction;
        QAction* mSaveAsProjectMenuAction;
        QAction* mSaveAsDatablockMenuAction;
        QAction* mSaveAsMeshMenuAction;
        QAction* mMaterialSetMenuAction;
        QAction* mMaterialPresetMenuAction;
        QAction* mMaterialClearMenuAction;
        QAction* mMaterialBrowserOpenMenuAction;
        QAction* mMaterialBrowserAddMenuAction;
        QAction* mTextureBrowserImportMenuAction;
        QAction* mNewPaintingLayerAction;
        QAction* mEditPaintingLayerAction;
        QAction* mDeleteSelectedPaintingLayersAction;
        QAction* mConfigureMenuAction;
        QAction* mTextureBrowserAddImageMenuAction;
        QAction* mRecentMaterialsFilesMenuAction;
        QAction* mRecentProjectFilesMenuAction;
        QAction* mQuitMenuAction;
        QAction* mResetWindowLayoutMenuAction;
        NodeEditorDockWidget* mNodeEditorDockWidget;
        CentralDockWidget* mCentralDockWidget;
        Magus::OgreManager* mOgreManager;
        QString mProjectName;
        QString mProjectPath;
        QString mMaterialFileName;
        QString mTextureFileName;
        QString mCurrentJsonFileName; // Used to determine whether a material was already saved; contains the json filename of the currently active material
        Ogre::IdString mCurrentDatablockId; // The datablock id
        Ogre::String mCurrentDatablockNameStr; // The datablocks' name
        bool mSaveTextureBrowserTimerActive;
        struct RecentFileStruct
        {
            RecentFileAction* action;
            QString fileName;
        };
        QList<RecentFileStruct> mRecentMaterialsFiles; // Used for recent Material files in menu
        QList<RecentFileStruct> mRecentProjectFiles; // Used for recent Project files in menu
        QPoint mMaterialBrowserPosition;
        QSize mMaterialBrowserSize;
        HlmsUtilsManager* mHlmsUtilsManager;
        Ogre::String mHelperName;
        QVector<int> helperIndices;
};

#endif

