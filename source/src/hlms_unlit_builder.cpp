/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include "constants.h"
#include "node_port.h"
#include "hlms_unlit_builder.h"
#include "OgreItem.h"
#include "OgreResourceGroupManager.h"

//****************************************************************************/
HlmsUnlitBuilder::HlmsUnlitBuilder(Magus::QtNodeEditor* nodeEditor) :
    HlmsBuilder(),
    mNodeEditor(nodeEditor)
{
}

//****************************************************************************/
HlmsUnlitBuilder::~HlmsUnlitBuilder(void)
{
}

//****************************************************************************/
void HlmsUnlitBuilder::deleteUnlitDatablock (Magus::OgreManager* ogreManager, const QString& datablockName)
{
    // Get the ogre manager, root and hlms managers
    Ogre::Root* root = ogreManager->getOgreRoot();
    Ogre::HlmsManager* hlmsManager = root->getHlmsManager();
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT) );
    Ogre::String name = datablockName.toStdString();
    if (hlmsUnlit->getDatablock(name))
    {
        // Destroy any existing datablock with that name
        Ogre::Item* item = ogreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getItem();
        //item->setDatablock(DEFAULT_DATABLOCK_NAME); // Set default datablock temporary, to release the datablock with name "HlmsDatablock"
        item->setDatablock(hlmsManager->getDefaultDatablock());
        hlmsUnlit->destroyDatablock(name);
    }
}

//****************************************************************************/
Ogre::HlmsUnlitDatablock* HlmsUnlitBuilder::createUnlitDatablock (Magus::OgreManager* ogreManager,
                                                                  QString latestDatablockName,
                                                                  HlmsNodeUnlitDatablock* unlitnode)
{
    // Get the ogre manager and root
    Ogre::Root* root = ogreManager->getOgreRoot();

    // Create a Unlit datablock
    Ogre::String datablockName = latestDatablockName.toStdString();
    Ogre::HlmsManager* hlmsManager = root->getHlmsManager();
    Ogre::HlmsTextureManager* hlmsTextureManager = hlmsManager->getTextureManager();
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT) );
    Ogre::Item* item = ogreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getItem();

    // First destroy any existing datablock with that name
    //item->setDatablock(DEFAULT_DATABLOCK_NAME); // Set default datablock temporary, to release the datablock with name "HlmsDatablock"
    item->setDatablock(hlmsManager->getDefaultDatablock());
    if (hlmsUnlit->getDatablock(datablockName))
        hlmsUnlit->destroyDatablock(datablockName);

    // Determine whether a macro node is attached (and enabled)
    Ogre::HlmsMacroblock macroblock;
    Magus::QtNode* node = unlitnode->getNodeConnectedToPort(PORT_MACROBLOCK);
    if (node)
    {
        // There is a macroblock; enrich it with the node data if enabled
        HlmsNodeMacroblock* macronode = static_cast<HlmsNodeMacroblock*>(node);
        if (macronode->getMacroblockEnabled())
            enrichMacroblock(macronode, &macroblock);
    }

    // Determine whether a blend node is attached (and enabled)
    Ogre::HlmsBlendblock blendblock;
    Magus::QtNode* bnode = unlitnode->getNodeConnectedToPort(PORT_BLENDBLOCK);
    if (bnode)
    {
        // There is a blendblock; enrich it with the node data if enabled
        HlmsNodeBlendblock* blendnode = static_cast<HlmsNodeBlendblock*>(bnode);
        if (blendnode->getBlendblockEnabled())
            enrichBlendblock(blendnode, &blendblock);
    }

    // Create a new datablock and use the (new) name defined in the node
    latestDatablockName = unlitnode->getName();
    datablockName = latestDatablockName.toStdString();
    Ogre::HlmsUnlitDatablock* datablock = static_cast<Ogre::HlmsUnlitDatablock*>(
                hlmsUnlit->createDatablock( datablockName,
                                            datablockName,
                                            macroblock,
                                            blendblock,
                                            Ogre::HlmsParamVec()));

    // Set the datablock properties
    enrichUnlitDatablock(datablock, unlitnode);

    // Run through all nodes connected to the unlitnode
    QVector<Magus::QtNode*> nodes = unlitnode->getNodes();
    Ogre::String texName;
    Ogre::String dataFolder;
    unsigned int texUnit = 0;
    foreach(Magus::QtNode* node, nodes)
    {
        if (node)
        {
            if (node->getType() == NODE_TYPE_SAMPLERBLOCK)
            {
                try
                {
                    // First check whether the texture/samperblock is enabled and must part of the datablock
                    HlmsNodeSamplerblock* samplernode = static_cast<HlmsNodeSamplerblock*>(node);
                    if (samplernode->getSamplerblockEnabled())
                    {
                        // Get the texture type from the sampler node and add a resourcelocation if needed
                        texName = samplernode->getBaseNameTexture().toStdString();
                        if (!texName.empty())
                        {
                            // Add resource location if needed
                            dataFolder = samplernode->getPathTexture().toStdString();
                            if (!isResourceLocationExisting(dataFolder))
                            {
                                root->addResourceLocation(dataFolder, "FileSystem", "General");
                                saveAllResourcesLocations();
                            }

                            // Get the texture from the samplernode
                            Ogre::HlmsTextureManager::TextureLocation texLocation = hlmsTextureManager->
                                    createOrRetrieveTexture(texName, Ogre::HlmsTextureManager::TEXTURE_TYPE_DIFFUSE);

                            // Create a samplerblock and add it to the datablock
                            Ogre::HlmsSamplerblock samplerblock;
                            enrichSamplerblock(datablock, &samplerblock, samplernode);
                            datablock->setTexture(texUnit, texLocation.xIdx, texLocation.texture);
                            datablock->setSamplerblock(texUnit, samplerblock);
                            ++texUnit;
                        }
                    }
                }
                catch (Ogre::Exception e)
                {
                    QMessageBox::information(0, QString("Error"), QString("Cannot create textures. Check Ogre.log"));
                }
            }
        }
    }

    // Set the datablock in the item
    item->setDatablock(datablock);
    return datablock;
}

//****************************************************************************/
HlmsNodeUnlitDatablock* HlmsUnlitBuilder::createUnlitNodeStructure(Magus::OgreManager* ogreManager,
                                                                   const QString& datablockName)
{
    // TODO
    return 0;
}

//****************************************************************************/
void HlmsUnlitBuilder::enrichUnlitDatablock(Ogre::HlmsUnlitDatablock* datablock,
                                            HlmsNodeUnlitDatablock* unlitnode)
{
    if (!datablock)
        return;

    if (!unlitnode)
        return;

    // ******** Colour ********
    Ogre::ColourValue colour;
    colour.r = (float)unlitnode->getColour().red() / 255.0f;
    colour.g = (float)unlitnode->getColour().green() / 255.0f;
    colour.b = (float)unlitnode->getColour().blue() / 255.0f;
    colour.a = (float)unlitnode->getColour().alpha() / 255.0f;

    // If the colour isn't white, set the flag
    if (colour != Ogre::ColourValue::White)
        datablock->setUseColour(true);
    else
        datablock->setUseColour(false);

    // Set the colour
    datablock->setColour(colour);

    // ******** Alphatest threshold ********
    datablock->setAlphaTest(getCompareFunctionFromIndex(unlitnode->getAlphaTest()));

    // ******** Alphatest threshold ********
    datablock->setAlphaTestThreshold(unlitnode->getAlphaTestThreshold());
}

//****************************************************************************/
void HlmsUnlitBuilder::enrichSamplerblock (Ogre::HlmsUnlitDatablock* datablock,
                                           Ogre::HlmsSamplerblock* samplerblock,
                                           HlmsNodeSamplerblock* samplernode)
{
    // ******** Generic properties ********
    enrichSamplerBlockGeneric(samplerblock, samplernode);

    // TODO: Specific properties
}

//****************************************************************************/
HlmsNodeUnlitDatablock* HlmsUnlitBuilder::createUnlitNode(void)
{
    HlmsNodeUnlitDatablock* node = new HlmsNodeUnlitDatablock(NODE_TITLE_UNLIT_DATABLOCK);
    node->setType(NODE_TYPE_UNLIT_DATABLOCK);
    mNodeEditor->addNode(node);
    return node;
}

//****************************************************************************/
void HlmsUnlitBuilder::connectNodes(HlmsNodeUnlitDatablock* unlitnode,
                                    HlmsNodeSamplerblock* samplernode)
{
    if (!unlitnode)
        return;

    if (!samplernode)
        return;

    // Reposition the unlit node (this is only done once)
    QPointF pos = unlitnode->pos();
    pos.setX(-1.5f * unlitnode->getWidth());
    pos.setY(-1.5f * unlitnode->getHeigth());
    unlitnode->setPos(pos);

    // Connect unlit and sampler
    Magus::QtPort* portUnlit = unlitnode->getFirstFreePort(PORT_ID_UNLIT_DATABLOCK, PORT_ID_UNLIT_DATABLOCK + 7);
    unlitnode->connectNode(PORT_ID_UNLIT_DATABLOCK,
                           PORT_ID_UNLIT_DATABLOCK + 7,
                           samplernode,
                           PORT_ID_SAMPLERBLOCK);

    // Reposition the sampler node
    pos.setX(pos.x() + unlitnode->getWidth() + 2 * portUnlit->pos().y());
    pos.setY(portUnlit->pos().y() - unlitnode->getHeigth());
    samplernode->setPos(pos);
}
