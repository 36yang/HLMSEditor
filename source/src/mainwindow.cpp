/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include "constants.h"
#include "magus_core.h"
#include <QString>
#include <QFile>
#include <QTextStream>
#include <QMenuBar>
#include <QSettings>
#include "mainwindow.h"
#include "OgreRoot.h"
#include "OgrePlugin.h"
#include "OgreMesh.h"
#include "OgreItem.h"
#include "OgreMeshManager.h"
#include "OgreMeshManager2.h"
#include "OgreMeshSerializer.h"
#include "OgreMesh2Serializer.h"
#include "OgreHlmsPbs.h"
#include "OgreHlmsUnlit.h"
#include "OgreHlmsPbsDatablock.h"
#include "OgreHlmsUnlitDatablock.h"
#include "OgreHlmsManager.h"
#include "OgreArchiveManager.h"
#include "OgreItem.h"
#include "hlms_builder.h"
#include "hlms_pbs_builder.h"
#include "hlms_unlit_builder.h"
#include "hlms_editor_plugin.h"
#include "hlms_editor_plugin_action.h"
#include "config_dialog.h"

//****************************************************************************/
MainWindow::MainWindow(void) :
    mIsClosing(false),
    mFirst(true),
    mSaveTextureBrowserTimerActive(false)
{
    installEventFilter(this);

    // Create the Ogre Manager
    mOgreManager = new Magus::OgreManager();
    mHlmsUtilsManager = new HlmsUtilsManager();
    newProjectName();
    mHlmsName = QString("");
    mCurrentDatablockFullName = Ogre::String("");
    mCurrentDatablockName = "";
    mTempString = QString("");
    mTempOgreString = "";
    
	// Perform standard functions
    createActions();
    createMenus();
    createToolBars();
    createStatusBar();
    createDockWindows();
    mMaterialBrowser = new MaterialBrowserDialog(this);
    connect(mMaterialBrowser, SIGNAL(okClicked(QString)), this, SLOT(doMaterialBrowserAccepted(QString)));
    connect(mMaterialBrowser, SIGNAL(cancelClicked()), this, SLOT(doMaterialBrowserRejected()));
    connect(mMaterialBrowser, SIGNAL(closeClicked()), this, SLOT(doMaterialBrowserClosed()));
    loadMaterialBrowserCfg();
    loadTextureBrowserCfg();
    loadRecentHlmsFilesCfg();
    loadRecentProjectFilesCfg();
    mOgreManager->initialize();

    // Disable shaderfile generation
    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
    hlmsPbs->setDebugOutputPath(false);
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));
    hlmsUnlit->setDebugOutputPath(false);

    // Set the title
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);

    // Set the stylesheet of the application
    QFile File(QString("dark.qss"));
    File.open(QFile::ReadOnly);
    QString styleSheet = QLatin1String(File.readAll());
    setStyleSheet(styleSheet);

    // Set the max. width/height of the mainwindow
    showMaximized();

    // Delete all datablocks that are loaded at startup, so that the datablock
    // administration in mHlmsUtilsManager is up-to-date
    mHlmsUtilsManager->destroyDatablocks(true); // Exclude the 'special' datablocks
}

//****************************************************************************/
MainWindow::~MainWindow(void)
{
    delete mHlmsUtilsManager;
    delete mOgreManager;
}

//****************************************************************************/
bool MainWindow::eventFilter(QObject* object, QEvent* event)
{
    if (event->type()==QEvent::KeyPress)
    {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if (key->key() == Qt::Key_F5)
        {
            // F5 was pressed
            mNodeEditorDockWidget->generateDatablock();
        }
        if (key->key() == Qt::Key_S && (QApplication::keyboardModifiers() & Qt::ControlModifier))
        {
            // CTRL+S was pressed
            doSaveDatablockMenuAction();
        }
    }
    return QObject::eventFilter(object, event);
}

//****************************************************************************/
void MainWindow::closeEvent(QCloseEvent* event)
{
    mIsClosing = true;
}

//****************************************************************************/
void MainWindow::createActions(void)
{
    // ******** File menu ********
    // New
    mNewProjectAction = new QAction(QString("New Project"), this);
    mNewProjectAction->setShortcut(QKeySequence(QString("Ctrl+Shift+N")));
    connect(mNewProjectAction, SIGNAL(triggered()), this, SLOT(doNewProjectAction()));
    mNewHlmsPbsAction = new QAction(QString("New Hlms Pbs"), this);
    mNewHlmsPbsAction->setShortcut(QKeySequence(QString("Ctrl+Alt+N")));
    connect(mNewHlmsPbsAction, SIGNAL(triggered()), this, SLOT(doNewHlmsPbsAction()));
    mNewHlmsUnlitAction = new QAction(QString("New Hlms Unlit"), this);
    mNewHlmsUnlitAction->setShortcut(QKeySequence(QString("Ctrl+N")));
    connect(mNewHlmsUnlitAction, SIGNAL(triggered()), this, SLOT(doNewHlmsUnlitAction()));

    // Open
    mOpenProjectMenuAction = new QAction(QString("Open Project"), this);
    mOpenProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+O")));
    connect(mOpenProjectMenuAction, SIGNAL(triggered()), this, SLOT(doOpenProjectMenuAction()));
    mOpenDatablockMenuAction = new QAction(QString("Open Hlms"), this);
    mOpenDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+O")));
    connect(mOpenDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doOpenDatablockMenuAction()));
    mOpenMeshMenuAction = new QAction(QString("Open Mesh"), this);
    mOpenMeshMenuAction->setShortcut(QKeySequence(QString("Ctrl+O")));
    connect(mOpenMeshMenuAction, SIGNAL(triggered()), this, SLOT(doOpenMeshMenuAction()));

    // Save
    mSaveProjectMenuAction = new QAction(QString("Save Project"), this);
    mSaveProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+S")));
    connect(mSaveProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveProjectMenuAction()));
    mSaveDatablockMenuAction = new QAction(QString("Save Hlms"), this);
    mSaveDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+S")));
    connect(mSaveDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveDatablockMenuAction()));

    // Save as
    mSaveAsProjectMenuAction = new QAction(QString("Save Project as"), this);
    mSaveAsProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+A")));
    connect(mSaveAsProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsProjectMenuAction()));
    mSaveAsDatablockMenuAction = new QAction(QString("Save Hlms as"), this);
    mSaveAsDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+A")));
    connect(mSaveAsDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsDatablockMenuAction()));
    mSaveAsMeshMenuAction = new QAction(QString("Save Mesh as"), this);
    mSaveAsMeshMenuAction->setShortcut(QKeySequence(QString("Ctrl+A")));
    connect(mSaveAsMeshMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsMeshMenuAction()));

    // Quit
    mQuitMenuAction = new QAction(QString("Quit"), this);
    mQuitMenuAction->setShortcut(QKeySequence(QString("Ctrl+Q")));
    connect(mQuitMenuAction, SIGNAL(triggered()), this, SLOT(doQuitMenuAction()));

    // ******** Materials menu ********
    mMaterialBrowserOpenMenuAction = new QAction(QString("Open browser"), this);
    mMaterialBrowserOpenMenuAction->setShortcut(QKeySequence(QString("Ctrl+B")));
    connect(mMaterialBrowserOpenMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserOpenMenuAction()));
    mMaterialBrowserAddMenuAction = new QAction(QString("Add Hlms to browser"), this);
    mMaterialBrowserAddMenuAction->setShortcut(QKeySequence(QString("Ctrl+H")));
    connect(mMaterialBrowserAddMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserAddMenuAction()));

    // ******** Texture menu ********
    mTextureBrowserImportMenuAction = new QAction(QString(ACTION_IMPORT_TEXTURES_FROM_DIR), this);
    mTextureBrowserImportMenuAction->setShortcut(QKeySequence(QString("Ctrl+I")));
    connect(mTextureBrowserImportMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserImportMenuAction()));
    mTextureBrowserAddImageMenuAction = new QAction(QString(ACTION_ADD_TEXTURES), this);
    mTextureBrowserAddImageMenuAction->setShortcut(QKeySequence(QString("Ctrl+T")));
    connect(mTextureBrowserAddImageMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserAddImageMenuAction()));

    // ******** Tools ********
    mConfigureMenuAction = new QAction(QString(ACTION_CONFIGURE), this);
    mConfigureMenuAction->setShortcut(QKeySequence(QString("Ctrl+X")));
    connect(mConfigureMenuAction, SIGNAL(triggered()), this, SLOT(doConfigureMenuAction()));

    // ******** Window menu ********
    mResetWindowLayoutMenuAction = new QAction(QString("Reset Window Layout"), this);
    mResetWindowLayoutMenuAction->setShortcut(QKeySequence(QString("Ctrl+R")));
    connect(mResetWindowLayoutMenuAction, SIGNAL(triggered()), this, SLOT(doResetWindowLayoutMenuAction()));
}

//****************************************************************************/
void MainWindow::createMenus(void)
{
    // ******** File ********
    mFileMenu = menuBar()->addMenu(QString("&File"));
    mMaterialBrowserMenu = menuBar()->addMenu(QString("&Materials"));
    mTextureBrowserMenu = menuBar()->addMenu(QString("&Textures"));
    QMenu* fileMenuAction = mFileMenu->addMenu("New");

    // New
    fileMenuAction->addAction(mNewProjectAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mNewHlmsPbsAction);
    fileMenuAction->addAction(mNewHlmsUnlitAction);

    // Open
    fileMenuAction = mFileMenu->addMenu("Open");
    fileMenuAction->addAction(mOpenProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenDatablockMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenMeshMenuAction);

    // Save
    fileMenuAction = mFileMenu->addMenu("Save");
    fileMenuAction->addAction(mSaveProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveDatablockMenuAction);

    // Save as
    fileMenuAction = mFileMenu->addMenu("Save as");
    fileMenuAction->addAction(mSaveAsProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveAsDatablockMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveAsMeshMenuAction);

    // Import/Export
    Ogre::Root::PluginInstanceList plugins = mOgreManager->getOgreRoot()->getInstalledPlugins();
    Ogre::Root::PluginInstanceList::iterator it;
    Ogre::Root::PluginInstanceList::iterator itStart = plugins.begin();
    Ogre::Root::PluginInstanceList::iterator itEnd = plugins.end();
    Ogre::Plugin* plugin;
    PluginAction* action;
    QMenu* fileMenuImportAction = 0;
    QMenu* fileMenuExportAction = 0;
    for (it = itStart; it != itEnd; ++it)
    {
        plugin = *it;
        if (plugin->getName() == GENERAL_HLMS_PLUGIN_NAME)
        {
            // It is a Hlms editor plugin
            Ogre::HlmsEditorPlugin* hlmsEditorPlugin = dynamic_cast<Ogre::HlmsEditorPlugin*>(plugin);
            if (hlmsEditorPlugin->isImport())
            {
                // First create an import menu item if needed
                if (!fileMenuImportAction)
                    fileMenuImportAction = mFileMenu->addMenu("Import");

                // Add the import action of the plugin to the submenu
                if (fileMenuImportAction)
                {
                    action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getImportMenuText().c_str(), this);
                    connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doImport(Ogre::HlmsEditorPlugin*)));
                    fileMenuImportAction->addAction(action);
                }
            }
            if (hlmsEditorPlugin->isExport())
            {
                // First create an export menu item if needed
                if (!fileMenuExportAction)
                    fileMenuExportAction = mFileMenu->addMenu("Export");

                // Add the export action of the plugin to the submenu
                if (fileMenuExportAction)
                {
                    action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getExportMenuText().c_str(), this);
                    connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doExport(Ogre::HlmsEditorPlugin*)));
                    fileMenuExportAction->addAction(action);
                }
            }
        }
    }

    // Recent Hlms files
    mRecentHlmsFilesMenu = mFileMenu->addMenu("Recent Hlms files");

    // Recent Hlms files
    mRecentProjectFilesMenu = mFileMenu->addMenu("Recent Project files");

    // Quit
    mFileMenu->addAction(mQuitMenuAction);

    // ******** Material browser ********
    mMaterialBrowserMenu->addAction(mMaterialBrowserOpenMenuAction);
    mMaterialBrowserMenu->addAction(mMaterialBrowserAddMenuAction);

    // ******** Texture browser ********
    mTextureBrowserMenu->addAction(mTextureBrowserImportMenuAction);
    mTextureBrowserMenu->addAction(mTextureBrowserAddImageMenuAction);

    // ******** Tools ********
    mWindowMenu = menuBar()->addMenu(QString("&Tools"));
    mWindowMenu->addAction(mConfigureMenuAction);

    // ******** Window ********
    mWindowMenu = menuBar()->addMenu(QString("&Window"));
    mWindowMenu->addAction(mResetWindowLayoutMenuAction);
}

//****************************************************************************/
void MainWindow::createToolBars(void)
{

}

//****************************************************************************/
void MainWindow::createStatusBar(void)
{

}

//****************************************************************************/
void MainWindow::createDockWindows(void)
{
    mRenderwindowDockWidget = new RenderwindowDockWidget("Renderwindow", this);
    addDockWidget(Qt::LeftDockWidgetArea, mRenderwindowDockWidget);
    mPropertiesDockWidget = new PropertiesDockWidget("Properties", this);
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);

    mTextureDockWidget = new TextureDockWidget("Textures", this);
    addDockWidget(Qt::RightDockWidgetArea, mTextureDockWidget);
    mNodeEditorDockWidget = new NodeEditorDockWidget("NodeEditor", this);
    addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);
    connect(mTextureDockWidget, SIGNAL(textureDoubleClicked(QString,QString)), this, SLOT(handleTextureDoubleClicked(QString,QString)));
    connect(mTextureDockWidget, SIGNAL(customContextMenuItemSelected(QString)), this, SLOT(handleCustomContextMenuItemSelected(QString)));
    connect(mTextureDockWidget, SIGNAL(textureMutationOccured()), this, SLOT(handleTextureMutationOccured()));
}

//****************************************************************************/
void MainWindow::doNewProjectAction(void)
{
    mOgreManager->pauseRendering(true);

    // Clear the material- and texture browser
    mMaterialBrowser->clearResources();
    mTextureDockWidget->clearResources();

    // Clear the property- and node widgets
    mPropertiesDockWidget->clear();
    mNodeEditorDockWidget->clear();
    newProjectName();

    // Set the datablock of the Item in the Ogre widget to 'default'
    // Also destroy the datablocks in memory; strictly speaking this is not required, but it cleans up a bit
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setDefaultDatablockItem();
    mHlmsUtilsManager->destroyDatablocks(true); // Exclude the 'special' datablocks
    mHlmsName = QString("");

    mOgreManager->pauseRendering(false);
}

//****************************************************************************/
void MainWindow::newProjectName(void)
{
    mProjectName = DEFAULT_PROJECT_NAME;
    mProjectPath = PROJECT_PATH;
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
}

//****************************************************************************/
void MainWindow::doNewHlmsPbsAction(void)
{
    mHlmsName = QString("");
    mNodeEditorDockWidget->newHlmsPbs();
}

//****************************************************************************/
void MainWindow::doNewHlmsUnlitAction(void)
{
    mHlmsName = QString("");
    mNodeEditorDockWidget->newHlmsUnlit();
}

//****************************************************************************/
void MainWindow::doOpenProjectMenuAction(void)
{
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Load the Project"),
                                            QString(""),
                                            QString("Hlms Project file (*.hlmp)"));

    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadProject(const QString& fileName)
{
    QApplication::setOverrideCursor(Qt::WaitCursor);
    if (!fileName.isEmpty())
    {
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");

        QFile file(mProjectPath + mProjectName + QString(".hlmp"));
        QString header;
        if (file.open(QFile::ReadOnly))
        {
            // Add resource location first; this is in case the textures etc. are not loaded
            mOgreManager->getOgreRoot()->addResourceLocation(mProjectPath.toStdString(), "FileSystem", "General");

            QTextStream readFile(&file);

            // Line 1
            header = readFile.readLine();
            if (header != HEADER_PROJECT)
            {
                QMessageBox::information(0, QString("Error"), QString("This is not a valid Project file"));
            }
            else
            {
                // Line 2
                QString materialFileName = readFile.readLine();
                info.setFile(materialFileName);
                if (info.exists() && info.isFile())
                {
                    mMaterialFileName = materialFileName;
                }

                // Line 3
                QString textureFileName = readFile.readLine();
                info.setFile(textureFileName);
                if (info.exists() && info.isFile())
                {
                    mTextureFileName = textureFileName;
                }

                // Load the material and texture config
                loadMaterialBrowserCfg();
                loadTextureBrowserCfg();
                file.close();
                setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
                appendRecentProject(fileName);
                mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setDefaultDatablockItem();
                mHlmsUtilsManager->destroyDatablocks(true); // Exclude the 'special' datablocks
                mHlmsName = QString("");
                mPropertiesDockWidget->clear();
                mNodeEditorDockWidget->clear();
            }
        }
    }

    // TODO:
    // Check the current mesh and determine which materials is uses
    // Iterate through the materialbrowser of the loaded project and load the
    // materials that are used in the mesh

    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doOpenDatablockMenuAction(void)
{
    // Load the materials
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Hlms file"),
                                            QString(""),
                                            QString("Json material (*.json)"));
    loadDatablockAndSet(fileName);
}

//****************************************************************************/
void MainWindow::loadDatablockAndSet(const QString jsonFileName)
{
    HlmsUtilsManager::DatablockStruct datablockStruct = mHlmsUtilsManager->loadDatablock(jsonFileName);
    if (!datablockStruct.datablock)
    {
        Ogre::LogManager::getSingleton().logMessage("MainWindow::loadDatablockAndSet -> Cannot continue; datablock is 0\n");
        return;
    }

    mHlmsName = jsonFileName;
    appendRecentHlms(jsonFileName);
    setCurrentDatablockNames (datablockStruct.datablockId, datablockStruct.datablockFullName);

    // Create the pbs node structure
    QString s = datablockStruct.datablockFullName.c_str();
    if (datablockStruct.type == EditorHlmsTypes::HLMS_PBS)
    {
        HlmsNodePbsDatablock* node = mNodeEditorDockWidget->createPbsNodeStructure(s);
        if (node)
        {
            node->setSelected(true);
            mNodeEditorDockWidget->nodeSelected(node);
        }
        mPropertiesDockWidget->setTextureTypePropertyVisible(true);
        mPropertiesDockWidget->setDetailMapPropertiesVisible(true);
    }
    else if (datablockStruct.type == EditorHlmsTypes::HLMS_UNLIT)
    {
        // Create the unlit node structure
        HlmsNodeUnlitDatablock* node = mNodeEditorDockWidget->createUnlitNodeStructure(s);
        if (node)
        {
            node->setSelected(true);
            mNodeEditorDockWidget->nodeSelected(node);
        }
        mPropertiesDockWidget->setTextureTypePropertyVisible(false);
        mPropertiesDockWidget->setDetailMapPropertiesVisible(false);
    }
}

//****************************************************************************/
void MainWindow::doOpenMeshMenuAction(void)
{
    // Load a mesh
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Mesh"),
                                            QString(""),
                                            QString("MESH (*.mesh);;"
                                                    "All files (*.*)"));
    if (!fileName.isEmpty())
    {
        mOgreManager->pauseRendering(true);
        loadMesh(fileName);
        mOgreManager->pauseRendering(false);
    }
}

//****************************************************************************/
void MainWindow::loadMesh(const QString meshFileName)
{
    if (!Magus::fileExist(meshFileName))
    {
        QMessageBox::information(0, QString("Warning"), meshFileName + QString(" does not exist."));
        return;
    }

    // 1. Mesh is an Ogre mesh?
    QFileInfo info(meshFileName);
    QString suffix = info.suffix();
    QString baseName = info.fileName();
    if (suffix != "mesh")
    {
        // Only Ogre3d meshes allowed for now
        QMessageBox::information(0, QString("Warning"), meshFileName + QString(" is not an Ogre3d mesh file."));
        return;
    }

    // 2. Check mesh version
    bool loaded = false;
    Ogre::String dataFolder = info.path().toStdString();
    if (isMeshV1 (meshFileName))
    {
        try
        {
            // Add the resource location first
            mOgreManager->getOgreRoot()->addResourceLocation(dataFolder, "FileSystem", "General");

            // Convert v1 mesh to v2 mesh
            Ogre::MeshPtr v2MeshPtr = convertMeshV1ToV2(baseName);

            // Create (by the scenemanager) an item and rtt item from the v2MeshPtr and set them in the ogre widget
            Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
            Ogre::Item* item = sceneManager->createItem(v2MeshPtr, Ogre::SCENE_DYNAMIC);
            Ogre::Item* itemRtt = sceneManager->createItem(v2MeshPtr, Ogre::SCENE_DYNAMIC);
            mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setItem(item, itemRtt, Ogre::Vector3::UNIT_SCALE);

            // Save the V2 mesh (ask whether it must be saved)
            /*
            QMessageBox::StandardButton reply;
            reply = QMessageBox::question(this, "Info", meshFileName +
                                          QString(" is converted to a V2 mesh. Do you want to save it?"),
                                          QMessageBox::Yes|QMessageBox::No);
            if (reply == QMessageBox::Yes)
            {
                // Save the mesh
                QString fileName = QFileDialog::getSaveFileName(this,
                                                                QString("Save the mesh"),
                                                                info.path() + QString("/.mesh"),
                                                                QString("V2 mesh file (*.mesh)"));

                if (!fileName.isEmpty())
                    saveV2Mesh(v2MeshPtr, fileName);
            }
            */

            // Add to mesh map
            mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));

            loaded = false;
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Error while converting V1 mesh ") + meshFileName);
        }
    }
    if (!loaded && isMeshV2 (meshFileName))
    {
        // 3. Load the V2 mesh
        try
        {
            // Add the resource location first
            mOgreManager->getOgreRoot()->addResourceLocation(dataFolder, "FileSystem", "General");

            // Create (by the ogre widget) the V2 mesh, the item and the rtt item
            mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->createItem(baseName.toStdString(), Ogre::Vector3::UNIT_SCALE);

            // Add to mesh map
            mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Cannot load ") + meshFileName);
        }
    }

    // 4. Load all materials needed in the mesh. Get them from the materialbrowser
    // Note, that it is assumed that the materialbrowser contains all the materials
    // needed for the mesh.
    // TODO:
    // - Get a list of material names from the mesh
    // - Search in the materialbrowser for the json files of those materials
    // - Call mHlmsUtilsManager to load the json files
}

//****************************************************************************/
void MainWindow::saveV2Mesh(Ogre::MeshPtr v2MeshPtr, QString meshFileName)
{
    Ogre::MeshSerializer meshSerializer( 0 );
    meshSerializer.exportMesh(v2MeshPtr.get(), meshFileName.toStdString());
}

//****************************************************************************/
bool MainWindow::isMeshV1(const QString meshFileName)
{
    Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
    if (!sceneManager)
        return false;

    Ogre::v1::MeshPtr v1MeshPtr;
    try
    {
        Ogre::v1::MeshSerializer meshSerializer;
        Ogre::DataStreamPtr stream(openFile(meshFileName.toStdString()));
        Ogre::String name = Ogre::StringConverter::toString(mOgreManager->getOgreRoot()->getTimer()->getMicroseconds());
        v1MeshPtr = Ogre::v1::MeshManager::getSingleton().createManual(name, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
        meshSerializer.importMesh(stream, v1MeshPtr.get());
        v1MeshPtr->unload();
    }
    catch (Ogre::Exception e)
    {
        return false;
    }

    return true;
}

//****************************************************************************/
bool MainWindow::isMeshV2(const QString meshFileName)
{
    Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
    if (!sceneManager)
        return false;

    Ogre::MeshPtr v2MeshPtr;
    try
    {
        Ogre::RenderSystem* renderSystem = mOgreManager->getOgreRoot()->getRenderSystem();
        Ogre::VaoManager* vaoManager = renderSystem->getVaoManager();
        Ogre::MeshSerializer meshSerializer(vaoManager);
        Ogre::DataStreamPtr stream(openFile(meshFileName.toStdString()));
        Ogre::String name = Ogre::StringConverter::toString(mOgreManager->getOgreRoot()->getTimer()->getMicroseconds());
        v2MeshPtr = Ogre::MeshManager::getSingleton().createManual(name, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
        meshSerializer.importMesh(stream, v2MeshPtr.get());
        v2MeshPtr->unload();
    }
    catch (Ogre::Exception e)
    {
        return false;
    }

    return true;
}

//****************************************************************************/
Ogre::MeshPtr MainWindow::convertMeshV1ToV2(const QString baseNameMeshV1)
{
    Ogre::v1::MeshPtr v1MeshPtr;
    Ogre::MeshPtr v2MeshPtr;

    // Create V1 mesh
    v1MeshPtr = Ogre::v1::MeshManager::getSingleton().load(
                baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,
                Ogre::v1::HardwareBuffer::HBU_STATIC, Ogre::v1::HardwareBuffer::HBU_STATIC);

    // Create V2 mesh
    v2MeshPtr = Ogre::MeshManager::getSingleton().createManual(baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
    v2MeshPtr->importV1 (v1MeshPtr.get(), true, true, true);
    v1MeshPtr->unload();
    return v2MeshPtr;
}


//****************************************************************************/
Ogre::DataStreamPtr MainWindow::openFile(Ogre::String source)
{
    struct stat tagStat;

    FILE* pFile = fopen( source.c_str(), "rb" );
    if (!pFile)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    stat( source.c_str(), &tagStat );
    Ogre::MemoryDataStream* memstream = new Ogre::MemoryDataStream(source, tagStat.st_size, true);
    size_t result = fread( (void*)memstream->getPtr(), 1, tagStat.st_size, pFile );
    if (result != tagStat.st_size)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    fclose( pFile );
    return Ogre::DataStreamPtr( memstream );
}

//****************************************************************************/
void MainWindow::destroyDatablock(const QString& datablockName)
{
    HlmsPbsBuilder pbsBuilder(0); // Do not pass the node editor (not needed in this case)
    HlmsUnlitBuilder unlitBuilder(0); // Do not pass the node editor (not needed in this case)
    pbsBuilder.deletePbsDatablock (mOgreManager, datablockName);
    unlitBuilder.deleteUnlitDatablock(mOgreManager, datablockName);
}

//****************************************************************************/
void MainWindow::getListOfResources(void)
{
    Ogre::ResourceGroupManager::ResourceManagerIterator it =
        Ogre::ResourceGroupManager::getSingletonPtr()->getResourceManagerIterator();
    while (it.hasMoreElements())
    {
        Ogre::ResourceManager* man = it.getNext();
        //Ogre::LogManager::getSingleton().logMessage("Resource Type = " + man->getResourceType()); // DEBUG
        Ogre::ResourceManager::ResourceMapIterator mapit = man->getResourceIterator() ;
        while (mapit.hasMoreElements())
        {
            Ogre::ResourcePtr ptr = mapit.getNext();
            //Ogre::LogManager::getSingleton().logMessage("Resource Name = " + ptr->getName()); // DEBUG
        }
    }
}

//****************************************************************************/
void MainWindow::doSaveProjectMenuAction(void)
{
    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Save material config
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    saveMaterialBrowserCfg();

    // Save texture config
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
    saveTextureBrowserCfg();

    // Save a project file
    QString fileName = mProjectPath + mProjectName + QString(".hlmp");
    QFile file(fileName);
    QString header = QString(HEADER_PROJECT);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        stream << header
               << "\n"
               << mMaterialFileName
               << "\n"
               << mTextureFileName
               << "\n";
        file.close();

        // Set title
        setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
        appendRecentProject(fileName);
    }
    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doSaveAsProjectMenuAction(void)
{
    // Save the project file
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    QString("Save the Project"),
                                                    mProjectName + QString(".hlmp"),
                                                    QString("Hlms Project file (*.hlmp)"));

    if (!fileName.isEmpty())
    {
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");
        doSaveProjectMenuAction();
    }
}

//****************************************************************************/
void MainWindow::doSaveDatablockMenuAction(void)
{
    if (mHlmsName.isEmpty())
        doSaveAsDatablockMenuAction();
    else
        saveDatablock();
}

//****************************************************************************/
void MainWindow::doSaveAsDatablockMenuAction(void)
{
    // Get hlms name
    //mHlmsName = QString(mNodeEditorDockWidget->getCurrentDatablockName());
    mHlmsName = mCurrentDatablockFullName.c_str();
    mHlmsName = mHlmsName + QString(".material.json");
    QString fileName = mHlmsName;

    // Save the datablock to one file
    fileName = QFileDialog::getSaveFileName(this,
                                            QString("Save the Hlms"),
                                            mHlmsName,
                                            QString("Json material (*.json)"));

    if (!fileName.isEmpty())
    {
        mHlmsName = fileName;
        saveDatablock();
    }
}

//****************************************************************************/
void MainWindow::saveDatablock(void)
{
    Ogre::String fname = mHlmsName.toStdString();
    QString baseNameJson = mHlmsName;
    baseNameJson = getBaseFileName(baseNameJson);
    QString thumb = baseNameJson + ".png";

    // Update the thumb image in the material browser
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());
    loadMaterialBrowserCfg();

    // Clear all other datablocks, except the current one
    // First, detach the datablocks from the Item
    detachMaterialsFromItem();

    // Destroy all special datablocks (axis, highlight and unlit rtt), otherwise they will also be saved or exported
    destroySpecialDatablocks();

    // Destroy the rest of the datablock, except the current one
    // Do not exclude special datablocks (although the are already destroyed
    // Keep the list with loaded materials
    // Do not destroy the current datablock
    mHlmsUtilsManager->destroyDatablocks(false, true, mCurrentDatablockFullName);

    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_PBS)
    {
        hlmsManager->saveMaterials (Ogre::HLMS_PBS, fname);
        appendRecentHlms(mHlmsName);
    }
    else if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_UNLIT)
    {
        hlmsManager->saveMaterials (Ogre::HLMS_UNLIT, fname);
        appendRecentHlms(mHlmsName);
    }

    // Recreate and attach the materials again
    mHlmsUtilsManager->reloadNonSpecialDatablocks(); // Reloades (and re-creates) the non-special datablocks
    createSpecialDatablocks(); // Create special-datablocks and set them in the right (sub)Item (if needed)
    restoreMaterialsOfItem(); // Set one or more of the reloaded datablocks back to the subitem in which it was
}

//****************************************************************************/
void MainWindow::doSaveAsMeshMenuAction(void)
{
    // Save the mesh
    QString meshFileName = "*.mesh";
    Ogre::MeshPtr v2MeshPtr = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getCurrentMeshWithMaterialNames();
    QFileInfo info(meshFileName);
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    QString("Save the mesh"),
                                                    info.path() + QString("/.mesh"),
                                                    QString("V2 mesh file (*.mesh)"));

    if (!fileName.isEmpty())
        saveV2Mesh(v2MeshPtr, fileName);
}

//****************************************************************************/
void MainWindow::loadMaterialBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mMaterialFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_SMALL_NO_PATH;

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel items
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->resourceName = QString("PBS");
             info->fullQualifiedName = QString("PBS");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
             resources.append(info);

             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->resourceName = QString("Unlit");
             info->fullQualifiedName = QString("Unlit");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mMaterialBrowser->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doQuitMenuAction(void)
{
    close();
}

//****************************************************************************/
void MainWindow::doMaterialBrowserOpenMenuAction(void)
{
    mMaterialBrowser->move(mMaterialBrowserPosition);
    mMaterialBrowser->resize(mMaterialBrowserSize);
    mMaterialBrowser->showNormal();
    mMaterialBrowser->raise();
}

//****************************************************************************/
void MainWindow::saveMaterialBrowserCfg(void)
{
    // Save all current settings
    const QVector<Magus::QtResourceInfo*>& resources = mMaterialBrowser->getResources();
    saveResources(mMaterialFileName, resources);
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAddMenuAction(void)
{
    if (mHlmsName.isEmpty())
        QMessageBox::information(0, QString("Error"), QString("No filename. The Hlms must be saved first"));
    else
    {
        QString baseNameJson = mHlmsName;
        baseNameJson = getBaseFileName(baseNameJson);
        QString thumb = baseNameJson + ".png";
        mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());

        if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_PBS)
            mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_PBS);
        else if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_UNLIT)
            mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_UNLIT);

        saveMaterialBrowserCfg();
    }
}

//****************************************************************************/
void MainWindow::doTextureBrowserImportMenuAction(void)
{
    QString textureFolder;
    QFileDialog dialog;
    dialog.setFileMode(QFileDialog::Directory);
    if (dialog.exec())
    {
        QStringList fileNames = dialog.selectedFiles();
        textureFolder = fileNames.at(0);

        // Add all texture files to a group in mTextureDockWidget
        QString fileName;

        QDirIterator dirIt(textureFolder, QDirIterator::Subdirectories);
        while (dirIt.hasNext())
        {
            dirIt.next();
            if (QFileInfo(dirIt.filePath()).isFile())
            {
                fileName = dirIt.fileName();
                if (Magus::isTypeBasedOnExtension(fileName, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS_LENGTH))
                {
                    fileName = textureFolder + QString("/") + fileName;
                    mTextureDockWidget->addTextureFile(fileName, GROUP_NAME_IMPORTED_TEXTURES); // Add it to a group
                }
            }
        }

        handleTextureMutationOccured();
    }
}

//****************************************************************************/
void MainWindow::doTextureBrowserAddImageMenuAction(void)
{
    QString fileName;
    QStringList fileNames;
    fileNames = QFileDialog::getOpenFileNames(this,
                                             QString("Select texture/image file(s)"),
                                             QString(""),
                                             QString("JPEG (*.jpg *.jpeg);;"
                                                     "PNG (*.png);;"
                                                     "DDS (*.dds);;"
                                                     "All files (*.*)"));
    foreach (fileName, fileNames)
    {
        if (!fileName.isEmpty())
            mTextureDockWidget->addTextureFile(fileName);
    }

    handleTextureMutationOccured();
}

//****************************************************************************/
void MainWindow::doConfigureMenuAction(void)
{
    ConfigDialog configDialog (this);
    configDialog.setMinimumWidth(400);
    configDialog.setMinimumHeight(400);
    if (configDialog.exec())
    {
        // TODO
    }
}

//****************************************************************************/
void MainWindow::doResetWindowLayoutMenuAction(void)
{
    mRenderwindowDockWidget->show();
    addDockWidget(Qt::LeftDockWidgetArea, mRenderwindowDockWidget);
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);

    mTextureDockWidget->show();
    addDockWidget(Qt::RightDockWidgetArea, mTextureDockWidget);
    mNodeEditorDockWidget->show();
    addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);
}

//****************************************************************************/
void MainWindow::handleTextureDoubleClicked(const QString& fileName, const QString& baseName)
{
    if (Magus::fileExist(fileName))
    {
        mNodeEditorDockWidget->newSamplerblockNode(fileName);
    }
    else
    {
        QMessageBox::StandardButton reply = fileDoesNotExistsWarning(fileName);
        if (reply == QMessageBox::Yes)
        {
            mTextureDockWidget->deleteTexture(fileName);
        }
    }
}

//****************************************************************************/
void MainWindow::handleCustomContextMenuItemSelected(const QString& menuItemText)
{
    if (menuItemText == ACTION_IMPORT_TEXTURES_FROM_DIR)
        doTextureBrowserImportMenuAction();
    else if (menuItemText == ACTION_ADD_TEXTURES)
        doTextureBrowserAddImageMenuAction();
}

//****************************************************************************/
void MainWindow::handleTextureMutationOccured(void)
{
    // Do not save immediately, but only after some time; this is to prevent that saveTextureBrowserCfg
    // is called for every mutation in the texture tree (deletion of 100 textures in one go
    // triggers handleTextureMutationOccured also 100 times. We don't want to save 100 times).
    // This is the reason that a QTimer is used.
    if (mSaveTextureBrowserTimerActive)
        return;

    QTimer::singleShot(1000, this, SLOT(saveTextureBrowserCfg()));
    mSaveTextureBrowserTimerActive = true;
}

//****************************************************************************/
void MainWindow::saveTextureBrowserCfg(void)
{
    mSaveTextureBrowserTimerActive = false;
    const QVector<Magus::QtResourceInfo*>& resources = mTextureDockWidget->getResources();
    saveResources(mTextureFileName, resources);
}

//****************************************************************************/
void MainWindow::loadTextureBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mTextureFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_TEXTURE_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_TEXTURE_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel item
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->resourceName = QString("Textures");
             info->fullQualifiedName = QString("Textures");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_TEXTURE_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mTextureDockWidget->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::saveResources(const QString& fileName, const QVector<Magus::QtResourceInfo*>& resources)
{
    // Save state of a resources from a resourcetree widget
    QFile file(fileName);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        QVectorIterator<Magus::QtResourceInfo*> it(resources);
        it.toFront();
        Magus::QtResourceInfo* info;
        while (it.hasNext())
        {
            // Write a line to the cfg file
            info = it.next();
            stream << info->topLevelId
                   << "\t"
                   << info->parentId
                   << "\t"
                   << info->resourceId
                   << "\t"
                   << info->resourceType
                   << "\t"
                   << info->resourceName
                   << "\t"
                   << info->fullQualifiedName
                   << "\n";
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::update(void)
{
    if (mOgreManager)
        mOgreManager->renderOgreWidgetsOneFrame();

    if (mFirst)
    {
        // Only do this once, otherwise it is not possible to change the widget manually (by means of keyboard)
        mRenderwindowDockWidget->updateTransformationWidgetFromOgreWidget();
        mFirst = false;
    }
}

//****************************************************************************/
void MainWindow::initCurrentDatablockFileName(void)
{
    mHlmsName = QString("");
    mPropertiesDockWidget->clear();
}

//****************************************************************************/
EditorHlmsTypes MainWindow::getCurrentDatablockType(void)
{
    return mNodeEditorDockWidget->getCurrentDatablockType();
}

//****************************************************************************/
QMessageBox::StandardButton MainWindow::fileDoesNotExistsWarning(const QString& fileName)
{
    return QMessageBox::question(0,
                                 "Warning",
                                 fileName + QString(" does not exist. Remove it from the texture browser?"),
                                 QMessageBox::Yes|QMessageBox::No);
}

//****************************************************************************/
void MainWindow::doImport(Ogre::HlmsEditorPlugin* plugin)
{
    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before import (to select the file to be imported)?
    if (plugin->isOpenFileDialogForImport())
    {
        QString fileName;
        fileName = QFileDialog::getOpenFileName(this, QString("Import"),
                                                QString(""),
                                                QString("(*.*)"));

        if (!fileName.isEmpty())
        {
            QFileInfo info(fileName);
            data.mInFileDialogName = info.fileName().toStdString();
            data.mInFileDialogBaseName = info.baseName().toStdString();
            data.mInFileDialogPath = (info.absolutePath() + QString("/")).toStdString();
            data.mInExportPath = data.mInFileDialogPath;
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No file selected"));
            return;
        }
    }

    // Perform pre-import actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_PRE_IMPORT_MK_DIR)
    {
        // Create the project directory
        QString path = QString::fromStdString(data.mInImportPath + data.mInFileDialogBaseName);
        QDir dir(path);
        if (!dir.exists())
        {
          dir.mkdir(".");
        }
    }

    // Perform pre-import actions (by the editor)
    // ... nothing yet

    // Perform pre-import actions (by the plugin)
    plugin->performPreImportActions();

    // Execute the import
    QApplication::setOverrideCursor(Qt::WaitCursor);
    Ogre::HlmsDatablock* oldDatablock = data.mInOutCurrentDatablock;
    Ogre::HlmsDatablock* newDatablock;
    bool result = plugin->executeImport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        // Check whether a new datablock was created
        newDatablock = data.mInOutCurrentDatablock;
        if (newDatablock && oldDatablock != newDatablock)
        {
            // Set the newDatablock to the Item?
            // TODO: Not sure what to do here
        }
        text = data.mOutSuccessText.c_str();
        if (text.isEmpty())
            text = QString ("Import completed");
        QMessageBox::information(0, QString("Info"), text);
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while importing");
        QMessageBox::information(0, QString("Error"), text);
    }

    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Perform post-import actions (by the plugin)
    plugin->performPostImportActions();

    // Perform post-import actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_SAVE_RESOURCE_LOCATIONS)
    {
        // Save all resource locations
        HlmsBuilder builder;
        builder.saveAllResourcesLocations();
    }
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_OPEN_PROJECT)
    {
        // Open a project (referered to by means of data.mOutExportReference)
        QString fileName = QString::fromStdString(data.mOutExportReference);
        loadProject(fileName);
    }

    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doExport(Ogre::HlmsEditorPlugin* plugin)
{
    // Make sure that the materials are not attached to the entity before they are deleted
    detachMaterialsFromItem();

    // Destroy the special datablocks
    destroySpecialDatablocks();

    // Do not destroy special datablocks and destroy all other datablocks, but keep the list with loaded
    // datablocks, although they are destroyed. This list is reused to recreate the datablocks again.
    mHlmsUtilsManager->destroyDatablocks(false, true);

    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before export (to select the dir to be exported)?
    if (plugin->isOpenFileDialogForExport())
    {
        QString textureFolder;
        QFileDialog dialog;
        dialog.setFileMode(QFileDialog::Directory);
        if (dialog.exec())
        {
            QStringList fileNames = dialog.selectedFiles();
            textureFolder = fileNames.at(0);
        }

        if (!textureFolder.isEmpty())
        {
            data.mInFileDialogPath = (textureFolder + QString("/")).toStdString();
            data.mInExportPath = data.mInFileDialogPath;
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No directory"));
            return;
        }
    }

    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Are the textures of all datablocks in the material browser needed?
    if (plugin->isTexturesUsedByDatablocksForExport())
    {
        // Reload all datablocks from the material browser
        std::vector<Ogre::String> materials;
        materials = data.mInMaterialFileNameVector;
        std::vector<Ogre::String>::iterator it = materials.begin();
        std::vector<Ogre::String>::iterator itEnd = materials.end();
        Ogre::String fileName = "";
        while (it != itEnd)
        {
            // Load the materials
            fileName = *it;
            if (!fileName.empty())
            {
                mHlmsUtilsManager->loadDatablock(fileName.c_str());
            }
            ++it;
        }

        // Get the texture basenames from the datablocks
        std::vector<Ogre::String> vPbs;
        std::vector<Ogre::String> vUnlit;
        HlmsPbsBuilder pbsBuilder(0); // Do not pass the node editor (not needed in this case)
        HlmsUnlitBuilder unlitBuilder(0); // Do not pass the node editor (not needed in this case)
        pbsBuilder.getTexturesFromAvailableDatablocks (mOgreManager, &vPbs);
        unlitBuilder.getTexturesFromAvailableDatablocks (mOgreManager, &vUnlit);

        // Add all textures from Pbs
        std::vector<Ogre::String>::iterator itPbs = vPbs.begin();
        std::vector<Ogre::String>::iterator itPbsEnd = vPbs.end();
        Ogre::String baseName;
        while (itPbs != itPbsEnd)
        {
            baseName = *itPbs;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itPbs;
        }

        // Add all textures from Unlit
        std::vector<Ogre::String>::iterator itUnlit = vUnlit.begin();
        std::vector<Ogre::String>::iterator itUnlitEnd = vUnlit.end();
        while (itUnlit != itUnlitEnd)
        {
            baseName = *itUnlit;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itUnlit;
        }
    }

    // Perform pre-export actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_PRE_EXPORT_DELETE_ALL_DATABLOCKS)
        mHlmsUtilsManager->destroyDatablocks(false, true); // Keep the list with loaded datablocks

    // Perform pre-export actions (by the plugin)
    plugin->performPreExportActions();

    // Execute the export
    bool result = plugin->executeExport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        text = data.mOutSuccessText.c_str();
        if (text.isEmpty())
            text = QString ("Export completed");
        QMessageBox::information(0, QString("Info"), text);
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while exporting");
        QMessageBox::information(0, QString("Error"), text);
    }

    // Perform post-export actions (by the plugin)
    plugin->performPostExportActions();

    // Perform post-export actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_POST_EXPORT_DELETE_ALL_DATABLOCKS)
        mHlmsUtilsManager->destroyDatablocks(false, true); // Keep the list with loaded datablocks

    // Recreate the datablocks from the list with datablocks that were loaded at the begin of this function
    mHlmsUtilsManager->reloadNonSpecialDatablocks();

    // Attach the datablocks to the subItems
    restoreMaterialsOfItem();

    // Recreate the special datablocks
    createSpecialDatablocks();
}

//****************************************************************************/
void MainWindow::constructHlmsEditorPluginData(Ogre::HlmsEditorPluginData* data)
{
    QOgreWidget* widget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    Ogre::Item* item = widget->getItem();
    data->mInItem = item;

    // mInMaterialFileNameVector
    data->mInMaterialFileName = mMaterialFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& materialResources = mMaterialBrowser->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itMaterials(materialResources);
    itMaterials.toFront();
    Magus::QtResourceInfo* info;
    data->mInMaterialFileNameVector.clear();
    while (itMaterials.hasNext())
    {
        // Only add real filenames (assets)
        info = itMaterials.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInMaterialFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    // mInTextureFileNameVector
    data->mInTextureFileName = mTextureFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& textureResources = mTextureDockWidget->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itTextures(textureResources);
    itTextures.toFront();
    data->mInTextureFileNameVector.clear();
    while (itTextures.hasNext())
    {
        // Only add real filenames (assets)
        info = itTextures.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInTextureFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    data->mInOutCurrentDatablock = item->getSubItem(0)->getDatablock();
    data->mInProjectName = mProjectName.toStdString();
    data->mInProjectPath = mProjectPath.toStdString();
    data->mInFileDialogName = "";
    data->mInFileDialogBaseName = "";
    data->mInFileDialogPath = "";

    // Use value from settings.cfg for import path
    QSettings settings(FILE_SETTINGS, QSettings::IniFormat);
    QString importPath = settings.value(SETTINGS_IMPORT_PATH).toString();
    if (importPath.isEmpty())
        importPath = DEFAULT_IMPORT_PATH;
    data->mInImportPath = importPath.toStdString();

    data->mInExportPath = "";
    data->mInRenderWindow = widget->getRenderWindow();
    data->mInSceneManager = widget->getSceneManager();
    data->mInTextureFileName = mTextureFileName.toStdString();
    data->mOutErrorText = "Error while performing this function";
    data->mOutExportReference = "";
    data->mOutSuccessText = "";
    data->mInTexturesUsedByDatablocks.clear();
}

//****************************************************************************/
void MainWindow::appendRecentHlms(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentHlmsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentHlmsFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentHlmsFiles.size() > MAX_RECENT_HLMS_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentHlmsFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentHlmsFilesMenu->removeAction(action);
        delete action;
        mRecentHlmsFiles.removeAt(0);
    }

    mRecentHlmsFiles.append(recentFiles);
    mRecentHlmsFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentHlmsFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentHlmsFilesCfg();
}

//****************************************************************************/
void MainWindow::appendRecentProject(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentProjectFiles.size() > MAX_RECENT_PROJECT_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentProjectFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentProjectFilesMenu->removeAction(action);
        delete action;
        mRecentProjectFiles.removeAt(0);
    }

    mRecentProjectFiles.append(recentFiles);
    mRecentProjectFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentProjectFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentProjectFilesCfg();
}

//****************************************************************************/
void MainWindow::doRecentHlmsFileAction(const QString& fileName)
{
    loadDatablockAndSet(fileName);
}

//****************************************************************************/
void MainWindow::doRecentProjectFileAction(const QString& fileName)
{
    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadRecentHlmsFilesCfg(void)
{
    QFile file(FILE_RECENT_HLMS_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentHlms(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentHlmsFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentHlmsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentHlmsFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_HLMS_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::loadRecentProjectFilesCfg(void)
{
    QFile file(FILE_RECENT_PROJECT_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentProject(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentProjectFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_PROJECT_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAccepted(const QString& fileName)
{
    // A change is made in the material browser and accepted with ok or double click on an item
    if (!fileName.isEmpty())
        loadDatablockAndSet(fileName);

    // Save all current settings
    saveMaterialBrowserCfg();
}

//****************************************************************************/
void MainWindow::doMaterialBrowserRejected(void)
{
    loadMaterialBrowserCfg(); // Reverses all changes
}

//****************************************************************************/
void MainWindow::doMaterialBrowserClosed(void)
{
    mMaterialBrowserPosition = mMaterialBrowser->pos();
    mMaterialBrowserSize = mMaterialBrowser->size();
}

//****************************************************************************/
void MainWindow::detachMaterialsFromItem (void)
{
    // Make a snaphost of the item's materials and set the default datablock
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->makeSnapshotOfItemMaterials();
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setDefaultDatablockItem();
}

//****************************************************************************/
void MainWindow::destroySpecialDatablocks(void)
{
    // Destroy the axis, highlight and rtt material
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->destroyLightAxisMaterial();
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->destroyHighlightMaterial();
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->destroyUnlitDatablocksRtt();
}

//****************************************************************************/
void MainWindow::restoreMaterialsOfItem (void)
{
    // First remove all 'dangling'  datablocks from mItem just in case
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setDefaultDatablockItem();

    // Restore the snapshot
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->restoreSnapshotOfItemMaterials();
}

//****************************************************************************/
void MainWindow::createSpecialDatablocks (void)
{
    // (Re)create the axis, highlight and rtt material
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->createLightAxisMaterial();
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->createHighlightMaterial();
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->createUnlitDatablocksRtt();
}

//****************************************************************************/
void MainWindow::setCurrentDatablockNames(const Ogre::IdString& name, const Ogre::String& fullName)
{
    mCurrentDatablockFullName = fullName;
    mCurrentDatablockName = name;
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setCurrentDatablockName(mCurrentDatablockName);
}
