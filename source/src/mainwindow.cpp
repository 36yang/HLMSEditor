/****************************************************************************
**
** Copyright (C) 2016 - 2017
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include "constants.h"
#include "magus_core.h"
#include <QString>
#include <QFile>
#include <QTextStream>
#include <QMenuBar>
#include <QSettings>
#include "mainwindow.h"
#include "OgreRoot.h"
#include "OgrePlugin.h"
#include "OgreMesh.h"
#include "OgreItem.h"
#include "OgreMeshManager.h"
#include "OgreMeshManager2.h"
#include "OgreMeshSerializer.h"
#include "OgreMesh2Serializer.h"
#include "OgreHlmsPbs.h"
#include "OgreHlmsUnlit.h"
#include "OgreHlmsPbsDatablock.h"
#include "OgreHlmsUnlitDatablock.h"
#include "OgreHlmsManager.h"
#include "OgreArchiveManager.h"
#include "OgreItem.h"
#include "hlms_builder.h"
#include "hlms_pbs_builder.h"
#include "hlms_unlit_builder.h"
#include "hlms_editor_plugin.h"
#include "hlms_editor_plugin_action.h"
#include "config_dialog.h"
#include "asset_propertywidget_xy.h"
#include "hlms_editor_plugin_properties_dialog.h"
#include <fstream>

//****************************************************************************/
MainWindow::MainWindow(void) :
    mIsClosing(false),
    mFirst(true),
    mSaveTextureBrowserTimerActive(false)
{
    // Delete all files in the 'temp' directory
    deleteTempPathRecursive();

    setMinimumSize(100,100);
    installEventFilter(this);

    // Create the Ogre Manager
    mOgreManager = new Magus::OgreManager();
    mHlmsUtilsManager = new HlmsUtilsManager();
    newProjectName();
    mCurrentJsonFileName = QString("");
    mCurrentDatablockNameStr = Ogre::String("");
    mCurrentDatablockId = "";
    mTempString = QString("");
    mTempOgreString = "";
    mHelperName = "";
    
	// Perform standard functions
    createActions();
    createMenus();
    createToolBars();
    createStatusBar();
    createDockWindows();
    mMaterialBrowser = new MaterialBrowserDialog(this);
    connect(mMaterialBrowser, SIGNAL(okClicked(QString)), this, SLOT(doMaterialBrowserAccepted(QString)));
    connect(mMaterialBrowser, SIGNAL(cancelClicked()), this, SLOT(doMaterialBrowserRejected()));
    connect(mMaterialBrowser, SIGNAL(closeClicked()), this, SLOT(doMaterialBrowserClosed()));
    loadMaterialBrowserCfg();
    loadTextureBrowserCfg();
    loadRecentMaterialFilesCfg();
    loadRecentProjectFilesCfg();
    mOgreManager->initialize();

    // Disable shaderfile generation
    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
    hlmsPbs->setDebugOutputPath(false, false);
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));
    hlmsUnlit->setDebugOutputPath(false, false);

    // Set the title
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);

    // Set the stylesheet of the application
    QFile File(QString("dark.qss"));
    File.open(QFile::ReadOnly);
    QString styleSheet = QLatin1String(File.readAll());
    setStyleSheet(styleSheet);

    // Set the max. width/height of the mainwindow
    showMaximized();

    // Delete all datablocks that are loaded at startup, so that the datablock
    // administration in mHlmsUtilsManager is up-to-date
    mHlmsUtilsManager->destroyDatablocks(true); // Exclude the 'special' datablocks

    // Display Qt's supported image formats in Ogre.log
    QList<QByteArray> formats = QImageReader::supportedImageFormats();
    QByteArray ba;
    QString supportedFormatString = tr("");
    QList<QByteArray>::iterator it = formats.begin();
    QList<QByteArray>::iterator itEnd = formats.end();
    while (it != itEnd)
    {
        ba = *it;
        QString str(ba);
        supportedFormatString += str + tr(", ");
        ++it;
    }
    Ogre::LogManager::getSingleton().logMessage("Supported Qt formats: " + supportedFormatString.toStdString());

    // Set the paintlayer pointer in the ogre widget (the widget is already created in the RenderwindowDockWidget)
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->setPaintLayers(mPaintLayerManager.getPaintLayers());
}

//****************************************************************************/
MainWindow::~MainWindow(void)
{
    mPaintLayerManager.removeAndDeleteAllPaintLayers();
    delete mHlmsUtilsManager;
    delete mOgreManager;
}

//****************************************************************************/
bool MainWindow::eventFilter(QObject* object, QEvent* event)
{
    if (event->type()==QEvent::KeyPress)
    {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if (key->key() == Qt::Key_F5)
        {
            // F5 was pressed
            mNodeEditorDockWidget->generateDatablock();
        }
        if (key->key() == Qt::Key_S && (QApplication::keyboardModifiers() & Qt::ControlModifier))
        {
            // CTRL+S was pressed
            doSaveDatablockMenuAction();
        }
    }
    return QObject::eventFilter(object, event);
}

//****************************************************************************/
void MainWindow::closeEvent(QCloseEvent* event)
{
    mIsClosing = true;
}

//****************************************************************************/
void MainWindow::createActions(void)
{
    // ******** File menu ********
    // New
    mNewProjectAction = new QAction(QString("New Project"), this);
    mNewProjectAction->setShortcut(QKeySequence(QString("Ctrl+Shift+N")));
    connect(mNewProjectAction, SIGNAL(triggered()), this, SLOT(doNewProjectAction()));
    mNewPbsMaterialAction = new QAction(QString("New Hlms Pbs"), this);
    mNewPbsMaterialAction->setShortcut(QKeySequence(QString("Ctrl+Alt+N")));
    connect(mNewPbsMaterialAction, SIGNAL(triggered()), this, SLOT(doNewPbsMaterialAction()));
    mNewUnlitMaterialAction = new QAction(QString("New Hlms Unlit"), this);
    mNewUnlitMaterialAction->setShortcut(QKeySequence(QString("Ctrl+N")));
    connect(mNewUnlitMaterialAction, SIGNAL(triggered()), this, SLOT(doNewUnlitMaterialAction()));

    // Open
    mOpenProjectMenuAction = new QAction(QString("Open Project"), this);
    mOpenProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+O")));
    connect(mOpenProjectMenuAction, SIGNAL(triggered()), this, SLOT(doOpenProjectMenuAction()));
    mOpenDatablockMenuAction = new QAction(QString("Open Hlms"), this);
    mOpenDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+O")));
    connect(mOpenDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doOpenDatablockMenuAction()));
    mOpenMeshMenuAction = new QAction(QString("Open Mesh"), this);
    mOpenMeshMenuAction->setShortcut(QKeySequence(QString("Ctrl+O")));
    connect(mOpenMeshMenuAction, SIGNAL(triggered()), this, SLOT(doOpenMeshMenuAction()));

    // Save
    mSaveProjectMenuAction = new QAction(QString("Save Project"), this);
    mSaveProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+S")));
    connect(mSaveProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveProjectMenuAction()));
    mSaveDatablockMenuAction = new QAction(QString("Save Hlms"), this);
    mSaveDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+S")));
    connect(mSaveDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveDatablockMenuAction()));

    // Save as
    mSaveAsProjectMenuAction = new QAction(QString("Save Project as"), this);
    mSaveAsProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+A")));
    connect(mSaveAsProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsProjectMenuAction()));
    mSaveAsDatablockMenuAction = new QAction(QString("Save Hlms as"), this);
    mSaveAsDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+A")));
    connect(mSaveAsDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsDatablockMenuAction()));
    mSaveAsMeshMenuAction = new QAction(QString("Save Mesh as"), this);
    mSaveAsMeshMenuAction->setShortcut(QKeySequence(QString("Ctrl+A")));
    connect(mSaveAsMeshMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsMeshMenuAction()));

    // Quit
    mQuitMenuAction = new QAction(QString("Quit"), this);
    mQuitMenuAction->setShortcut(QKeySequence(QString("Ctrl+Q")));
    connect(mQuitMenuAction, SIGNAL(triggered()), this, SLOT(doQuitMenuAction()));

    // ******** Materials menu ********
    mMaterialSetMenuAction = new QAction(QString("Apply current material to (sub)mesh"), this);
    mMaterialSetMenuAction->setShortcut(QKeySequence(QString("Ctrl+M")));
    connect(mMaterialSetMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialSetMenuAction()));

    mMaterialEditMenuAction = new QAction(QString(ACTION_EDIT_SUBMESH_MATERIAL), this);
    connect(mMaterialEditMenuAction, SIGNAL(triggered()), this, SLOT(doEditMaterialOfSubmeshMenuAction()));

    mMaterialBrowserOpenMenuAction = new QAction(QString("Open materialbrowser"), this);
    mMaterialBrowserOpenMenuAction->setShortcut(QKeySequence(QString("Ctrl+B")));
    connect(mMaterialBrowserOpenMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserOpenMenuAction()));

    mMaterialBrowserAddMenuAction = new QAction(QString("Add material to materialbrowser"), this);
    mMaterialBrowserAddMenuAction->setShortcut(QKeySequence(QString("Ctrl+H")));
    connect(mMaterialBrowserAddMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserAddMenuAction()));

    mMaterialPresetMenuAction = new QAction(QString("Material as preset"), this);
    mMaterialPresetMenuAction->setShortcut(QKeySequence(QString("Ctrl+C")));
    connect(mMaterialPresetMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialPresetMenuAction()));

    mMaterialClearMenuAction = new QAction(QString("Clear all materials (from memory)"), this);
    mMaterialClearMenuAction->setShortcut(QKeySequence(QString("Ctrl+Y")));
    connect(mMaterialClearMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialClearMenuAction()));

    // ******** Texture menu ********
    mTextureBrowserImportMenuAction = new QAction(QString(ACTION_IMPORT_TEXTURES_FROM_DIR), this);
    mTextureBrowserImportMenuAction->setShortcut(QKeySequence(QString("Ctrl+I")));
    connect(mTextureBrowserImportMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserImportMenuAction()));
    mTextureBrowserAddImageMenuAction = new QAction(QString(ACTION_ADD_TEXTURES), this);
    mTextureBrowserAddImageMenuAction->setShortcut(QKeySequence(QString("Ctrl+T")));
    connect(mTextureBrowserAddImageMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserAddImageMenuAction()));

    // ******** Painting ********
    mNewPaintingLayerAction = new QAction(QString(ACTION_NEW_PAINTING_LAYER), this);
    mNewPaintingLayerAction->setShortcut(QKeySequence(QString("Ctrl+P")));
    connect(mNewPaintingLayerAction, SIGNAL(triggered()), this, SLOT(doNewPaintingLayerMenuAction()));
    mEditPaintingLayerAction = new QAction(QString(ACTION_EDIT_PAINTING_LAYER), this);
    mEditPaintingLayerAction->setShortcut(QKeySequence(QString("Ctrl+E")));
    connect(mEditPaintingLayerAction, SIGNAL(triggered()), this, SLOT(doNewEditLayerMenuAction()));
    mDeleteSelectedPaintingLayersAction = new QAction(QString(ACTION_DELETE_CURRENT_PAINT_LAYERS), this);
    mDeleteSelectedPaintingLayersAction->setShortcut(QKeySequence(QString("Ctrl+D")));
    connect(mDeleteSelectedPaintingLayersAction, SIGNAL(triggered()), this, SLOT(doSelectedPaintingLayersMenuAction()));

    // ******** Tools ********
    mConfigureMenuAction = new QAction(QString(ACTION_CONFIGURE), this);
    mConfigureMenuAction->setShortcut(QKeySequence(QString("Ctrl+X")));
    connect(mConfigureMenuAction, SIGNAL(triggered()), this, SLOT(doConfigureMenuAction()));

    // ******** Window menu ********
    mResetWindowLayoutMenuAction = new QAction(QString("Reset Window Layout"), this);
    mResetWindowLayoutMenuAction->setShortcut(QKeySequence(QString("Ctrl+R")));
    connect(mResetWindowLayoutMenuAction, SIGNAL(triggered()), this, SLOT(doResetWindowLayoutMenuAction()));
}

//****************************************************************************/
void MainWindow::createMenus(void)
{
    // ******** File ********
    mFileMenu = menuBar()->addMenu(QString("&File"));
    QMenu* fileMenuAction = mFileMenu->addMenu("New");

    // New
    fileMenuAction->addAction(mNewProjectAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mNewPbsMaterialAction);
    fileMenuAction->addAction(mNewUnlitMaterialAction);

    // Open
    fileMenuAction = mFileMenu->addMenu("Open");
    fileMenuAction->addAction(mOpenProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenDatablockMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenMeshMenuAction);

    // Save
    fileMenuAction = mFileMenu->addMenu("Save");
    fileMenuAction->addAction(mSaveProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveDatablockMenuAction);

    // Save as
    fileMenuAction = mFileMenu->addMenu("Save as");
    fileMenuAction->addAction(mSaveAsProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveAsDatablockMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveAsMeshMenuAction);

    // Import/Export
    Ogre::Root::PluginInstanceList plugins = mOgreManager->getOgreRoot()->getInstalledPlugins();
    Ogre::Root::PluginInstanceList::iterator it;
    Ogre::Root::PluginInstanceList::iterator itStart = plugins.begin();
    Ogre::Root::PluginInstanceList::iterator itEnd = plugins.end();
    Ogre::Plugin* plugin;
    PluginAction* action;
    QMenu* fileMenuImportAction = 0;
    QMenu* fileMenuExportAction = 0;
    for (it = itStart; it != itEnd; ++it)
    {
        plugin = *it;
        if (plugin->getName() == GENERAL_HLMS_PLUGIN_NAME)
        {
            // It is a Hlms editor plugin
            Ogre::HlmsEditorPlugin* hlmsEditorPlugin = dynamic_cast<Ogre::HlmsEditorPlugin*>(plugin);
            if (hlmsEditorPlugin->isImport())
            {
                // First create an import menu item if needed
                if (!fileMenuImportAction)
                    fileMenuImportAction = mFileMenu->addMenu("Import");

                // Add the import action of the plugin to the submenu
                if (fileMenuImportAction)
                {
                    action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getImportMenuText().c_str(), this);
                    connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doImport(Ogre::HlmsEditorPlugin*)));
                    fileMenuImportAction->addAction(action);
                }
            }
            if (hlmsEditorPlugin->isExport())
            {
                // First create an export menu item if needed
                if (!fileMenuExportAction)
                    fileMenuExportAction = mFileMenu->addMenu("Export");

                // Add the export action of the plugin to the submenu
                if (fileMenuExportAction)
                {
                    action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getExportMenuText().c_str(), this);
                    connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doExport(Ogre::HlmsEditorPlugin*)));
                    fileMenuExportAction->addAction(action);
                }
            }
        }
    }

    // Recent Hlms files
    mRecentMaterialsFilesMenu = mFileMenu->addMenu("Recent Hlms files");

    // Recent Hlms files
    mRecentProjectFilesMenu = mFileMenu->addMenu("Recent Project files");

    // Quit
    mFileMenu->addAction(mQuitMenuAction);

    // ******** Material browser ********
    mMaterialMenu = menuBar()->addMenu(QString("&Materials"));
    mMaterialMenu->addAction(mMaterialSetMenuAction);
    mMaterialMenu->addAction(mMaterialEditMenuAction);
    mMaterialMenu->addAction(mMaterialBrowserOpenMenuAction);
    mMaterialMenu->addAction(mMaterialBrowserAddMenuAction);
    mMaterialMenu->addAction(mMaterialPresetMenuAction);
    mMaterialMenu->addAction(mMaterialClearMenuAction);

    // ******** Texture browser ********
    mTextureMenu = menuBar()->addMenu(QString("&Textures"));
    mTextureMenu->addAction(mTextureBrowserImportMenuAction);
    mTextureMenu->addAction(mTextureBrowserAddImageMenuAction);

    // ******** Painting ********
    mWindowMenu = menuBar()->addMenu(QString("&Painting"));
    mWindowMenu->addAction(mNewPaintingLayerAction);
    mWindowMenu->addAction(mEditPaintingLayerAction);
    mWindowMenu->addAction(mDeleteSelectedPaintingLayersAction);

    // ******** Tools ********
    mWindowMenu = menuBar()->addMenu(QString("&Tools"));
    mWindowMenu->addAction(mConfigureMenuAction);

    // ******** Window ********
    mWindowMenu = menuBar()->addMenu(QString("&Window"));
    mWindowMenu->addAction(mResetWindowLayoutMenuAction);
}

//****************************************************************************/
void MainWindow::createToolBars(void)
{

}

//****************************************************************************/
void MainWindow::createStatusBar(void)
{

}

//****************************************************************************/
void MainWindow::createDockWindows(void)
{
    // Set property and texture widgets
    mPropertiesDockWidget = new PropertiesDockWidget("Properties", this);
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);
    mTextureDockWidget = new TextureDockWidget("Textures", this);
    addDockWidget(Qt::LeftDockWidgetArea, mTextureDockWidget);

    // Central dock widget
    mCentralDockWidget = new CentralDockWidget("", this);
    mNodeEditorDockWidget = new NodeEditorDockWidget("NodeEditor", this);
    mRenderwindowDockWidget = new RenderwindowDockWidget("Renderwindow", this);
    setCentralWidget(mCentralDockWidget);
    mCentralDockWidget->addDockWidget(Qt::RightDockWidgetArea, mRenderwindowDockWidget);
    mCentralDockWidget->addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);

    // Paint dock widget
    mPaintDockWidget = new PaintDockWidget("Paint", this); // The paint dockwidget uses the paint layer manager
    mPaintLayerDockWidget = new PaintLayerDockWidget(&mPaintLayerManager, "Paint layers", this); // The paintlayer dockwidget uses the paint layer manager
    mBrushPresetDockWidget = new BrushPresetDockWidget("Brushes", this);
    addDockWidget(Qt::RightDockWidgetArea, mPaintDockWidget);
    mPaintDockWidget->addDockWidget(Qt::RightDockWidgetArea, mPaintLayerDockWidget);
    mPaintDockWidget->addDockWidget(Qt::RightDockWidgetArea, mBrushPresetDockWidget);

    connect(mTextureDockWidget, SIGNAL(textureDoubleClicked(QString,QString)), this, SLOT(handleTextureDoubleClicked(QString,QString)));
    connect(mTextureDockWidget, SIGNAL(customContextMenuItemSelected(QString)), this, SLOT(handleCustomContextMenuItemSelected(QString)));
    connect(mTextureDockWidget, SIGNAL(textureMutationOccured()), this, SLOT(handleTextureMutationOccured()));
}

//****************************************************************************/
void MainWindow::doNewProjectAction(void)
{
    mOgreManager->setPause(true);

    deleteAllMaterials();

    // Clear the texture browser
    mTextureDockWidget->clearResources();

    // Reset project name
    newProjectName();

    mOgreManager->setPause(false);
}

//****************************************************************************/
void MainWindow::newProjectName(void)
{
    mProjectName = DEFAULT_PROJECT_NAME;
    mProjectPath = PROJECT_PATH;
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
}

//****************************************************************************/
void MainWindow::doNewPbsMaterialAction(void)
{
    clearNamesAndRemovePaintLayers();
    mNodeEditorDockWidget->newHlmsPbs();
}

//****************************************************************************/
void MainWindow::doNewUnlitMaterialAction(void)
{
    clearNamesAndRemovePaintLayers();
    mNodeEditorDockWidget->newHlmsUnlit();
}

//****************************************************************************/
void MainWindow::doOpenProjectMenuAction(void)
{
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Load the Project"),
                                            QString(""),
                                            QString("Hlms Project file (*.hlmp)"));

    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadProject(const QString& fileName)
{
    // When a new project is loaded, keep the datablocks of the previous project loaded
    // This way it is possible to assign datablocks from different projects to one item/mesh
    QApplication::setOverrideCursor(Qt::WaitCursor);
    if (!fileName.isEmpty())
    {
        clearNamesAndRemovePaintLayers();

        //QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");

        QFile file(mProjectPath + mProjectName + QString(".hlmp"));
        QString header;
        if (file.open(QFile::ReadOnly))
        {
            // Add resource location first; this is in case the textures etc. are not loaded
            addResourceLocationPath(mProjectPath);
            QTextStream readFile(&file);

            // Line 1
            header = readFile.readLine();
            if (header != HEADER_PROJECT)
            {
                QMessageBox::information(0, QString("Error"), QString("This is not a valid Project file"));
            }
            else
            {
                // Line 2
                QString materialFileName = readFile.readLine();
                info.setFile(materialFileName);
                if (info.exists() && info.isFile())
                {
                    mMaterialFileName = materialFileName;
                }

                // Line 3
                QString textureFileName = readFile.readLine();
                info.setFile(textureFileName);
                if (info.exists() && info.isFile())
                {
                    mTextureFileName = textureFileName;
                }

                // Load the material and texture config
                loadMaterialBrowserCfg();
                loadTextureBrowserCfg();
                file.close();
                setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
                appendRecentProjectToRecentlyUsed(fileName);

                // Enrich the item in the renderwindow with datablocks from the material browser.
                // This is based on the materialnames in its corresponding mesh.
                // Iterate through the materialbrowser of the loaded project and load the
                // materials that are used in the mesh.
                setDatablocksFromMaterialBrowserInItem();

                mPropertiesDockWidget->clear();
                mNodeEditorDockWidget->clear();
            }
        }
    }

    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doOpenDatablockMenuAction(void)
{
    // Load the materials
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Hlms file"),
                                            QString(""),
                                            QString("Json material (*.json)"));
    loadMaterialAndCreateNodeStructure(fileName);
}

//****************************************************************************/
void MainWindow::loadMaterialAndCreateNodeStructure(const QString jsonFileName)
{
    // Clear paintlayers and reset names
    clearNamesAndRemovePaintLayers();

    // Add the resource location first (for textures)
    addResourceLocationFile(jsonFileName);

    // First check whether the material exists; it is does, delete it
    // This function actually uses the jsonfile to retrieve the details
    // If the datablock exist, it is deleted first; otherwise it is not possible to create a datablock with an existing (in memory)name
    Ogre::IdString datablockId = mHlmsUtilsManager->parseJsonAndRetrieveName(jsonFileName);
    if (datablockId != "")
        deleteMaterial(datablockId);

    // Load the datablock
    HlmsUtilsManager::DatablockStruct datablockStruct = mHlmsUtilsManager->loadDatablock(jsonFileName);
    if (!datablockStruct.datablock)
    {
        Ogre::LogManager::getSingleton().logMessage("MainWindow::loadMaterialAndCreateNodeStructure -> Cannot continue; datablock is 0\n");
        return;
    }

    mCurrentJsonFileName = jsonFileName;
    appendRecentMaterialToRecentlyUsed(jsonFileName);
    setCurrentDatablockIdAndNameStr (datablockStruct.datablockId, datablockStruct.datablockNameStr);

    // Create the pbs node structure
    if (datablockStruct.type == HLMS_PBS)
    {
        HlmsNodePbsDatablock* node = mNodeEditorDockWidget->createPbsNodeStructure(datablockStruct);
        if (node)
        {
            node->setSelected(true);
            mNodeEditorDockWidget->nodeSelected(node);
        }
        mPropertiesDockWidget->setTextureTypePropertyVisible(true);
        mPropertiesDockWidget->setDetailMapWOSPropertiesVisible(true);
        mPropertiesDockWidget->setDetailMapAnimationPropertiesVisible(false);
    }
    else if (datablockStruct.type == HLMS_UNLIT)
    {
        // Create the unlit node structure
        HlmsNodeUnlitDatablock* node = mNodeEditorDockWidget->createUnlitNodeStructure(datablockStruct);
        if (node)
        {
            node->setSelected(true);
            mNodeEditorDockWidget->nodeSelected(node);
        }
        mPropertiesDockWidget->setTextureTypePropertyVisible(false);
        mPropertiesDockWidget->setDetailMapWOSPropertiesVisible(false);
        mPropertiesDockWidget->setDetailMapAnimationPropertiesVisible(true);
    }
}

//****************************************************************************/
void MainWindow::createNodeStructure (Ogre::IdString datablockId)
{
     HlmsUtilsManager::DatablockStruct datablockStruct = mHlmsUtilsManager->getDatablock(datablockId);
     mCurrentJsonFileName = datablockStruct.jsonFileName.c_str();
     appendRecentMaterialToRecentlyUsed(datablockStruct.jsonFileName.c_str());
     setCurrentDatablockIdAndNameStr (datablockStruct.datablockId, datablockStruct.datablockNameStr);

     // Create the pbs node structure
     if (datablockStruct.type == HLMS_PBS)
     {
         HlmsNodePbsDatablock* node = mNodeEditorDockWidget->createPbsNodeStructure(datablockStruct);
         if (node)
         {
             node->setSelected(true);
             mNodeEditorDockWidget->nodeSelected(node);
         }
         mPropertiesDockWidget->setTextureTypePropertyVisible(true);
         mPropertiesDockWidget->setDetailMapWOSPropertiesVisible(true);
         mPropertiesDockWidget->setDetailMapAnimationPropertiesVisible(false);
     }
     else if (datablockStruct.type == HLMS_UNLIT)
     {
         // Create the unlit node structure
         HlmsNodeUnlitDatablock* node = mNodeEditorDockWidget->createUnlitNodeStructure(datablockStruct);
         if (node)
         {
             node->setSelected(true);
             mNodeEditorDockWidget->nodeSelected(node);
         }
         mPropertiesDockWidget->setTextureTypePropertyVisible(false);
         mPropertiesDockWidget->setDetailMapWOSPropertiesVisible(false);
         mPropertiesDockWidget->setDetailMapAnimationPropertiesVisible(true);
     }
}

//****************************************************************************/
void MainWindow::doOpenMeshMenuAction(void)
{
    // Load a mesh
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Mesh"),
                                            QString(""),
                                            QString("MESH (*.mesh);;"
                                                    "All files (*.*)"));
    if (!fileName.isEmpty())
    {
        QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
        mOgreManager->setPause(true);
        ogreWidget->setEnabled(false);
        loadMesh(fileName);
        ogreWidget->setEnabled(true);
        mOgreManager->setPause(false);
    }
}

//****************************************************************************/
void MainWindow::loadMesh(const QString meshFileName)
{
    if (!Magus::fileExist(meshFileName))
    {
        QMessageBox::information(0, QString("Warning"), meshFileName + QString(" does not exist."));
        return;
    }

    // 1. Mesh is an Ogre mesh?
    QFileInfo info(meshFileName);
    QString suffix = info.suffix();
    QString baseName = info.fileName();
    if (suffix != "mesh")
    {
        // Only Ogre3d meshes allowed for now
        QMessageBox::information(0, QString("Warning"), meshFileName + QString(" is not an Ogre3d mesh file."));
        return;
    }

    // 2. Check mesh version
    bool loaded = false;
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    if (isMeshV1 (meshFileName))
    {
        try
        {
            // Add the resource location first
            addResourceLocationFile(meshFileName);

            // Convert v1 mesh to v2 mesh
            Ogre::MeshPtr v2MeshPtr = convertMeshV1ToV2(baseName);

            // Create (by the ogre widget) the V2 mesh, the item and the rtt item
            if (v2MeshPtr.isNull())
            {
                 QMessageBox::information(0, QString("Error"), QString("Failed to load ") + meshFileName);
                loaded = false;
            }
            else
            {
                ogreWidget->createItem(v2MeshPtr.getPointer()->getName(), Ogre::Vector3::UNIT_SCALE);
                v2MeshPtr.setNull();

                // Add to mesh map
                mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));

                loaded = true;
            }
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Error while converting V1 mesh ") + meshFileName);
        }
    }
    if (!loaded && isMeshV2 (meshFileName))
    {
        // 3. Load the V2 mesh
        try
        {
            // Add the resource location first
            addResourceLocationFile(meshFileName);

            // Create (by the ogre widget) the V2 mesh, the item and the rtt item
            ogreWidget->createItem(baseName.toStdString(), Ogre::Vector3::UNIT_SCALE);

            // Add to mesh map
            mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Cannot load ") + meshFileName);
        }
    }

    // 4. Datablocks from a project are already loaded by now as part of loading the projet
    // or as part of newly created materials. There is no need to call funtion
    // setDatablocksFromMaterialBrowserInItem() again
}

//****************************************************************************/
void MainWindow::saveV2Mesh(Ogre::MeshPtr v2MeshPtr, QString meshFileName)
{
    Ogre::MeshSerializer meshSerializer( 0 );
    meshSerializer.exportMesh(v2MeshPtr.get(), meshFileName.toStdString());
}

//****************************************************************************/
bool MainWindow::isMeshV1(const QString meshFileName)
{
    return (getMeshVersion(meshFileName) == 1);
}

//****************************************************************************/
bool MainWindow::isMeshV2(const QString meshFileName)
{
    return (getMeshVersion(meshFileName) == 2);
}

//****************************************************************************/
unsigned int MainWindow::getMeshVersion(const QString meshFileName)
{
    /* Use different method compared to earlier versions of HLMSEditor. Easier is to read the mesh file itself and determine the version.
     * Ogre V1 meshes bytes 02.. 19 are filled with "[MeshSerializer_v1", while V2 meshes are filled with "[MeshSerializer_v2".
     */
    std::ifstream ifs(meshFileName.toStdString(), std::ios::binary|std::ios::ate);
    std::vector<char>result(19);
    result[18] = 0;
    ifs.seekg(2, std::ios::beg); // Offset is 2nd byte
    ifs.read(&result[0], 18); // Read 18 chars
    ifs.close();
    QString versionText = QString::fromLatin1( &result[0]);
    if (versionText == MESH_VERSION_1)
        return 1;
    if (versionText == MESH_VERSION_2)
        return 2;

    return 0;
}

//****************************************************************************/
Ogre::MeshPtr MainWindow::convertMeshV1ToV2(const QString baseNameMeshV1)
{
    // If the resource exist, it can only be a V2 mesh (V1 meshes are not supported in the editor); just return it
    Ogre::MeshPtr v2MeshPtr;
    if (Ogre::MeshManager::getSingleton().resourceExists(baseNameMeshV1.toStdString()))
    {
        v2MeshPtr = Ogre::MeshManager::getSingleton().getByName(baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
        return v2MeshPtr;
    }

    Ogre::v1::MeshPtr v1MeshPtr;

    // Create V1 mesh
    v1MeshPtr = Ogre::v1::MeshManager::getSingleton().load(
                baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                Ogre::v1::HardwareBuffer::HBU_STATIC, Ogre::v1::HardwareBuffer::HBU_STATIC);

    v2MeshPtr = Ogre::MeshManager::getSingleton().createManual(baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
    v2MeshPtr->importV1 (v1MeshPtr.get(), true, true, true);
    v1MeshPtr->unload();
    v1MeshPtr.setNull();
    return v2MeshPtr;
}

//****************************************************************************/
Ogre::DataStreamPtr MainWindow::openFile(Ogre::String source)
{
    struct stat tagStat;

    FILE* pFile = fopen( source.c_str(), "rb" );
    if (!pFile)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    stat( source.c_str(), &tagStat );
    Ogre::MemoryDataStream* memstream = new Ogre::MemoryDataStream(source, tagStat.st_size, true);
    size_t result = fread( (void*)memstream->getPtr(), 1, tagStat.st_size, pFile );
    if (result != tagStat.st_size)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    fclose( pFile );
    return Ogre::DataStreamPtr( memstream );
}

//****************************************************************************/
void MainWindow::getListOfResources(void)
{
    Ogre::ResourceGroupManager::ResourceManagerIterator it =
        Ogre::ResourceGroupManager::getSingletonPtr()->getResourceManagerIterator();
    while (it.hasMoreElements())
    {
        Ogre::ResourceManager* man = it.getNext();
        //Ogre::LogManager::getSingleton().logMessage("Resource Type = " + man->getResourceType()); // DEBUG
        Ogre::ResourceManager::ResourceMapIterator mapit = man->getResourceIterator() ;
        while (mapit.hasMoreElements())
        {
            Ogre::ResourcePtr ptr = mapit.getNext();
            //Ogre::LogManager::getSingleton().logMessage("Resource Name = " + ptr->getName()); // DEBUG
        }
    }
}

//****************************************************************************/
void MainWindow::doSaveProjectMenuAction(void)
{
    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Save material config
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    saveMaterialBrowserCfg();

    // Save texture config
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
    saveTextureBrowserCfg();

    // Save a project file
    QString fileName = mProjectPath + mProjectName + QString(".hlmp");
    QFile file(fileName);
    QString header = QString(HEADER_PROJECT);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        stream << header
               << "\n"
               << mMaterialFileName
               << "\n"
               << mTextureFileName
               << "\n";
        file.close();

        // Set title
        setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
        appendRecentProjectToRecentlyUsed(fileName);
    }
    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doSaveAsProjectMenuAction(void)
{
    // Save the project file
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    QString("Save the Project"),
                                                    mProjectName + QString(".hlmp"),
                                                    QString("Hlms Project file (*.hlmp)"));

    if (!fileName.isEmpty())
    {
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");
        doSaveProjectMenuAction();
    }
}

//****************************************************************************/
void MainWindow::doSaveDatablockMenuAction(void)
{
    if (mCurrentJsonFileName.isEmpty())
        doSaveAsDatablockMenuAction();
    else
    {
        saveDatablock(true);
    }
}

//****************************************************************************/
void MainWindow::doSaveAsDatablockMenuAction(void)
{
    if (!continueEvenIfThereArePaintLayers())
        return;

    // Get hlms name
    mCurrentJsonFileName = mCurrentDatablockNameStr.c_str();
    mCurrentJsonFileName = mCurrentJsonFileName + QString(".material.json");
    QString fileName = mCurrentJsonFileName;

    // Save the datablock to one file
    fileName = QFileDialog::getSaveFileName(this,
                                            QString("Save the Hlms"),
                                            mCurrentJsonFileName,
                                            QString("Json material (*.json)"));

    if (!fileName.isEmpty())
    {
        mCurrentJsonFileName = fileName;
        saveDatablock(false);
    }
}

//****************************************************************************/
void MainWindow::saveDatablock(bool validatePaintLayers)
{
    // This is the new version of save datablock. With the introduction of HlmsManager::saveMaterial
    // it isn't needed anymore to delete all datablocks except the one-to-be-saved.

    // If validation is needed, then validate whether there are paintlayers (Pbs only)
    if (validatePaintLayers && !continueEvenIfThereArePaintLayers())
        return;

    Ogre::String fname = mCurrentJsonFileName.toStdString();
    QString baseNameJson = mCurrentJsonFileName;
    baseNameJson = getBaseFileName(baseNameJson);
    QString thumb = baseNameJson + ".png";

    // Update the thumb image in the material browser
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());
    loadMaterialBrowserCfg();

    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsDatablock* datablock = hlmsManager->getDatablock(mCurrentDatablockId);
    if (!datablock)
        return;

    if (mPaintLayerManager.texturesUsedInPaintLayers())
    {
        // Replace the current textures in the datablock with the saved ones
        TypeAndNewTextureNames typeAndNewTextureNames = mPaintLayerManager.saveTexturesWithTimeStampToImportDir();
        {
            TypeAndNewTextureNames::iterator it;
            TypeAndNewTextureNames::iterator itStart = typeAndNewTextureNames.begin();
            TypeAndNewTextureNames::iterator itEnd = typeAndNewTextureNames.end();
            Ogre::PbsTextureTypes type;
            Ogre::String filename;
            for (it = itStart; it != itEnd; ++it)
            {
                type = it->first;
                filename = it->second;
                mHlmsUtilsManager->replaceTextureInPbsDatablock(datablock->getName(), type, filename);
            }
        }
        hlmsManager->saveMaterial (datablock, fname);
        loadMaterialAndCreateNodeStructure(fname.c_str()); // Reload, because this also updates everything in the editor
    }
    else
    {
        // Just save the datablock
        hlmsManager->saveMaterial (datablock, fname);
    }

    appendRecentMaterialToRecentlyUsed(mCurrentJsonFileName);
}

//****************************************************************************/
bool MainWindow::continueEvenIfThereArePaintLayers(void)
{
    if (mPaintLayerManager.texturesUsedInPaintLayers())
    {
        QMessageBox::StandardButton reply;
        reply = QMessageBox::question(0, "", "There are textures assigned to paintlayers.\n"
                                             "Updated textures are saved as new image files in the /import directory.\n"
                                             "Do you still want to save?", QMessageBox::Ok|QMessageBox::Cancel);

        // If Ok pressed, true is returned; false is returned in case of Cancel
        return reply == QMessageBox::Ok;
    }

    return true; // Continue, because there are no paintlayers
}

//****************************************************************************/
void MainWindow::doSaveAsMeshMenuAction(void)
{
    // Save the mesh
    QString meshFileName = "*.mesh";
    Ogre::MeshPtr v2MeshPtr = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getCurrentMeshEnrichedWithItemDatablocksNameStr();
    QFileInfo info(meshFileName);
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    QString("Save the mesh"),
                                                    info.path() + QString("/.mesh"),
                                                    QString("V2 mesh file (*.mesh)"));

    if (!fileName.isEmpty())
        saveV2Mesh(v2MeshPtr, fileName);
}

//****************************************************************************/
void MainWindow::loadMaterialBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mMaterialFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_SMALL_NO_PATH;

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel items
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->resourceName = QString("PBS");
             info->fullQualifiedName = QString("PBS");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
             resources.append(info);

             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->resourceName = QString("Unlit");
             info->fullQualifiedName = QString("Unlit");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mMaterialBrowser->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doQuitMenuAction(void)
{
    close();
}

//****************************************************************************/
void MainWindow::doMaterialSetMenuAction(void)
{
    applyCurrentMaterialToMesh();
}

//****************************************************************************/
void MainWindow::applyCurrentMaterialToMesh(void)
{
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->assignCurrentDatablock();
}

//****************************************************************************/
void MainWindow::doEditMaterialOfSubmeshMenuAction(void)
{
    applyEditMaterialOfSubmeshMenuAction();
}

//****************************************************************************/
void MainWindow::loadAllMaterialsFromMaterialBrowser (void)
{
    // Load all materials of the material browser (unfortunately), because the relation between the materialname
    // of the mesh and the jsonfilename / datablock name can only be made when a resource is loaded.
    // It is not 100% sure that the resourcename (stored in the material browser structure) is also
    // the actual full datablock name. This can only be determined when the datablock is loaded;
    // The mHlmsUtilsManager keeps track of the loaded resources and their full name, hash name, ...etc.
    const QVector<Magus::QtResourceInfo*>& resources = mMaterialBrowser->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itResources(resources);
    itResources.toFront();
    Magus::QtResourceInfo* info;
    while (itResources.hasNext())
    {
        info = itResources.next();
        mHlmsUtilsManager->loadDatablock(info->fullQualifiedName);
    }
}

//****************************************************************************/
void MainWindow::applyEditMaterialOfSubmeshMenuAction(void)
{
    // Determine the datablock id of the selected (sub)mesh, load the corresponding material and apply it to the (sub)mesh
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    int subItemIndex = ogreWidget->getIndexOfHighlightedSubmesh();
    if (subItemIndex < 0)
        return;

    Ogre::LogManager::getSingleton().logMessage("subItemIndex > -1: "); // TEST
    Ogre::IdString id = ogreWidget->getDatablockOfHighlightedSubmesh(); // Get the current id of the material (not the 'green' one) of the highlighted submesh
    createNodeStructure(id);
}

//****************************************************************************/
void MainWindow::doMaterialBrowserOpenMenuAction(void)
{
    mMaterialBrowser->move(mMaterialBrowserPosition);
    mMaterialBrowser->resize(mMaterialBrowserSize);
    mMaterialBrowser->showNormal();
    mMaterialBrowser->raise();
}

//****************************************************************************/
void MainWindow::saveMaterialBrowserCfg(void)
{
    // Save all current settings
    const QVector<Magus::QtResourceInfo*>& resources = mMaterialBrowser->getResources();
    saveResources(mMaterialFileName, resources);
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAddMenuAction(void)
{
    if (mCurrentJsonFileName.isEmpty())
        QMessageBox::information(0, QString("Error"), QString("No filename. The Hlms must be saved first"));
    else
    {
        QString baseNameJson = mCurrentJsonFileName;
        baseNameJson = getBaseFileName(baseNameJson);
        QString thumb = baseNameJson + ".png";
        mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());

        if (getCurrentDatablockType() == HLMS_PBS)
            mMaterialBrowser->addMaterial(baseNameJson, mCurrentJsonFileName, thumb, HLMS_PBS);
        else if (getCurrentDatablockType() == HLMS_UNLIT)
            mMaterialBrowser->addMaterial(baseNameJson, mCurrentJsonFileName, thumb, HLMS_UNLIT);

        saveMaterialBrowserCfg();
    }
}

//****************************************************************************/
void MainWindow::doMaterialPresetMenuAction (void)
{
    if (mCurrentJsonFileName.isEmpty())
        QMessageBox::information(0, QString("Error"), QString("No filename. The Hlms must be saved first"));
    else
    {
        // Create the directory under PRESET_PATH_QSTRING
        QFileInfo info(mCurrentJsonFileName);
        QString presetPath = PRESET_PATH_QSTRING + info.baseName();
        QDir dir(presetPath);
        if (!dir.exists())
        {
          dir.mkdir(".");
        }
        presetPath = presetPath + "/";

        // Copy the (saved) hlms
        QString baseNameJson = mCurrentJsonFileName;
        baseNameJson = getBaseFileName(baseNameJson);
        QFile::copy(mCurrentJsonFileName, presetPath + baseNameJson);

        // Create the thumb
        QString thumb = baseNameJson + ".png";
        mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile((presetPath + thumb).toStdString());

        // Copy the textures
        std::vector<Ogre::String> v;
        Ogre::String s;
        QString sourceTextureFileName;
        QString targetTextureFileName;
        mHlmsUtilsManager->getFullyQualifiedTextureFileNamesFromRegisteredDatablock(mCurrentDatablockId, &v);
        std::vector<Ogre::String>::const_iterator it;
        std::vector<Ogre::String>::const_iterator itStart = v.begin();
        std::vector<Ogre::String>::const_iterator itEnd = v.end();
        for (it = itStart; it != itEnd; ++it)
        {
            s = *it;
            sourceTextureFileName = s.c_str();
            QFileInfo fileInfo(sourceTextureFileName);
            targetTextureFileName = fileInfo.fileName();
            targetTextureFileName = targetTextureFileName;
            QFile::copy(sourceTextureFileName, presetPath + targetTextureFileName);
        }

        // Add thumb to preset widget
        mBrushPresetDockWidget->addPreset (presetPath, thumb);

        /* Delete the datablock, otherwise it cannot be loaded if selected as preset.
         * If not deleted the following happens:
         * The datablock name was registered with a full qualified jsonfilename.
         * Once it becomes a preset, the full qualified jsonfilename becomes different, because the path differs.
         * If the datablock was not deleted, it tries to reload with the new json filename. This is not possible.
         */
        deleteMaterial (mCurrentDatablockId);
    }
}

//****************************************************************************/
void MainWindow::doMaterialClearMenuAction (void)
{
    deleteAllMaterials ();
}

//****************************************************************************/
void MainWindow::deleteCurrentMaterial(void)
{
    deleteMaterial (mCurrentDatablockId);
}

//****************************************************************************/
void MainWindow::deleteMaterial(const Ogre::IdString& id)
{
    Ogre::IdString idToBeDeleted = id; // Must be locally copied, because clearNamesAndRemovePaintLayers() resets the current id (mCurrentDatablockId)
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    if (idToBeDeleted == mCurrentDatablockId)
    {
        clearNamesAndRemovePaintLayers();
        mPropertiesDockWidget->clear();
        mNodeEditorDockWidget->clear();
    }

    ogreWidget->removeDatablockFromItem(idToBeDeleted);
    mHlmsUtilsManager->destroyDatablock(idToBeDeleted);
}

//****************************************************************************/
void MainWindow::deleteAllMaterials(void)
{
    // Clear all painting layers
    clearNamesAndRemovePaintLayers();

    // Clear the material browser
    mMaterialBrowser->clearResources();

    // Clear the property- and node widgets
    mPropertiesDockWidget->clear();
    mNodeEditorDockWidget->clear();

    // Set the datablock of the Item in the Ogre widget to 'default'
    // Also destroy the datablocks in memory
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->setDefaultDatablockItem();
    mHlmsUtilsManager->destroyDatablocks(true); // Exclude the 'special' datablocks
}

//****************************************************************************/
void MainWindow::doTextureBrowserImportMenuAction(void)
{
    QString textureFolder;
    QFileDialog dialog;
    dialog.setFileMode(QFileDialog::Directory);
    if (dialog.exec())
    {
        QStringList fileNames = dialog.selectedFiles();
        textureFolder = fileNames.at(0);

        // Add all texture files to a group in mTextureDockWidget
        QString fileName;

        QDirIterator dirIt(textureFolder, QDirIterator::Subdirectories);
        while (dirIt.hasNext())
        {
            dirIt.next();
            if (QFileInfo(dirIt.filePath()).isFile())
            {
                fileName = dirIt.fileName();
                if (Magus::isTypeBasedOnExtension(fileName, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS_LENGTH))
                {
                    fileName = textureFolder + QString("/") + fileName;
                    mTextureDockWidget->addTextureFile(fileName, GROUP_NAME_IMPORTED_TEXTURES); // Add it to a group
                }
            }
        }

        handleTextureMutationOccured();
    }
}

//****************************************************************************/
void MainWindow::doTextureBrowserAddImageMenuAction(void)
{
    QString fileName;
    QStringList fileNames;
    fileNames = QFileDialog::getOpenFileNames(this,
                                             QString("Select texture/image file(s)"),
                                             QString(""),
                                             QString("JPEG (*.jpg *.jpeg);;"
                                                     "PNG (*.png);;"
                                                     "DDS (*.dds);;"
                                                     "All files (*.*)"));
    foreach (fileName, fileNames)
    {
        if (!fileName.isEmpty())
            mTextureDockWidget->addTextureFile(fileName);
    }

    handleTextureMutationOccured();
}

//****************************************************************************/
void MainWindow::doNewPaintingLayerMenuAction(void)
{
    mPaintLayerDockWidget->createPaintLayer(); // Automaticall results in setting the paintlayer in the Ogre widget
}

//****************************************************************************/
void MainWindow::doEditPaintingLayerMenuAction(void)
{
    mPaintLayerDockWidget->editSelectedPaintLayer();
}

//****************************************************************************/
void MainWindow::doSelectedPaintingLayersMenuAction(void)
{
    mPaintLayerDockWidget->deleteSelectedPaintLayer();
}

//****************************************************************************/
void MainWindow::doConfigureMenuAction(void)
{
    ConfigDialog configDialog (this);
    configDialog.setMinimumWidth(400);
    configDialog.setMinimumHeight(400);
    if (configDialog.exec())
    {
        configDialog.saveSettings();
    }
}

//****************************************************************************/
void MainWindow::doResetWindowLayoutMenuAction(void)
{
    // Set property and texture widgets
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);
    addDockWidget(Qt::LeftDockWidgetArea, mTextureDockWidget);
    mPropertiesDockWidget->show();
    mTextureDockWidget->show();

    // Central dock widget
    setCentralWidget(mCentralDockWidget);
    mCentralDockWidget->addDockWidget(Qt::RightDockWidgetArea, mRenderwindowDockWidget);
    mCentralDockWidget->addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);
    mRenderwindowDockWidget->show();
    mCentralDockWidget->show();
    mNodeEditorDockWidget->show();

    // Paint dock widget
    addDockWidget(Qt::RightDockWidgetArea, mPaintDockWidget);
    mPaintDockWidget->addDockWidget(Qt::RightDockWidgetArea, mPaintLayerDockWidget);
    mPaintDockWidget->addDockWidget(Qt::RightDockWidgetArea, mBrushPresetDockWidget);
    mPaintDockWidget->show();
    mPaintDockWidget->show();
    mBrushPresetDockWidget->show();
}

//****************************************************************************/
void MainWindow::handleTextureDoubleClicked(const QString& fileName, const QString& baseName)
{
    if (Magus::fileExist(fileName))
    {
        mNodeEditorDockWidget->newSamplerblockNode(fileName);
    }
    else
    {
        QMessageBox::StandardButton reply = fileDoesNotExistsWarning(fileName);
        if (reply == QMessageBox::Yes)
        {
            mTextureDockWidget->deleteTexture(fileName);
        }
    }
}

//****************************************************************************/
void MainWindow::handleCustomContextMenuItemSelected(const QString& menuItemText)
{
    if (menuItemText == ACTION_IMPORT_TEXTURES_FROM_DIR)
        doTextureBrowserImportMenuAction();
    else if (menuItemText == ACTION_ADD_TEXTURES)
        doTextureBrowserAddImageMenuAction();
}

//****************************************************************************/
void MainWindow::handleTextureMutationOccured(void)
{
    // Do not save immediately, but only after some time; this is to prevent that saveTextureBrowserCfg
    // is called for every mutation in the texture tree (deletion of 100 textures in one go
    // triggers handleTextureMutationOccured also 100 times. We don't want to save 100 times).
    // This is the reason that a QTimer is used.
    if (mSaveTextureBrowserTimerActive)
        return;

    QTimer::singleShot(1000, this, SLOT(saveTextureBrowserCfg()));
    mSaveTextureBrowserTimerActive = true;
}

//****************************************************************************/
void MainWindow::saveTextureBrowserCfg(void)
{
    mSaveTextureBrowserTimerActive = false;
    const QVector<Magus::QtResourceInfo*>& resources = mTextureDockWidget->getResources();
    saveResources(mTextureFileName, resources);
}

//****************************************************************************/
void MainWindow::loadTextureBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mTextureFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_TEXTURE_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_TEXTURE_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel item
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->resourceName = QString("Textures");
             info->fullQualifiedName = QString("Textures");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_TEXTURE_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mTextureDockWidget->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::saveResources(const QString& fileName, const QVector<Magus::QtResourceInfo*>& resources)
{
    // Save state of a resources from a resourcetree widget
    QFile file(fileName);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        QVectorIterator<Magus::QtResourceInfo*> it(resources);
        it.toFront();
        Magus::QtResourceInfo* info;
        while (it.hasNext())
        {
            // Write a line to the cfg file
            info = it.next();
            stream << info->topLevelId
                   << "\t"
                   << info->parentId
                   << "\t"
                   << info->resourceId
                   << "\t"
                   << info->resourceType
                   << "\t"
                   << info->resourceName
                   << "\t"
                   << info->fullQualifiedName
                   << "\n";
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::update(void)
{
    if (mOgreManager)
        mOgreManager->renderOgreWidgetsOneFrame();

    if (mFirst)
    {
        // Only do this once, otherwise it is not possible to change the widget manually (by means of keyboard)
        mRenderwindowDockWidget->updateTransformationWidgetFromOgreWidget();
        mFirst = false;
    }
}

//****************************************************************************/
void MainWindow::initCurrentMaterialFileName(void)
{
    clearNamesAndRemovePaintLayers();
    mPropertiesDockWidget->clear();
}

//****************************************************************************/
EditorHlmsTypes MainWindow::getCurrentDatablockType(void)
{
    return mNodeEditorDockWidget->getCurrentDatablockType();
}

//****************************************************************************/
QMessageBox::StandardButton MainWindow::fileDoesNotExistsWarning(const QString& fileName)
{
    return QMessageBox::question(0,
                                 "Warning",
                                 fileName + QString(" does not exist. Remove it from the texture browser?"),
                                 QMessageBox::Yes|QMessageBox::No);
}

//****************************************************************************/
void MainWindow::doImport(Ogre::HlmsEditorPlugin* plugin)
{
    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before import? (to select the file to be imported)?
    if (!doImportOpenFileDialog (plugin, &data))
        return;

    // Is a properties dialog needed before import?
    doImportExportPropertiesDialog (plugin, &data);

    // Perform pre-import actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_PRE_IMPORT_MK_DIR)
    {
        // Create the project directory
        QString path = QString::fromStdString(data.mInImportPath + data.mInFileDialogBaseName);
        QDir dir(path);
        if (dir.exists())
            dir.removeRecursively();

          dir.mkdir(".");
    }

    // Perform pre-import actions (by the editor)
    // ... nothing yet

    // Perform pre-import actions (by the plugin)
    plugin->performPreImportActions();

    // Execute the import
    QApplication::setOverrideCursor(Qt::WaitCursor);
    Ogre::HlmsDatablock* oldDatablock = data.mInOutCurrentDatablock;
    Ogre::HlmsDatablock* newDatablock;
    bool result = plugin->executeImport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        if (!(plugin->getActionFlag() & Ogre::PAF_POST_ACTION_SUPPRESS_OK_MESSAGE))
        {
            // Check whether a new datablock was created
            newDatablock = data.mInOutCurrentDatablock;
            if (newDatablock && oldDatablock != newDatablock)
            {
                // Set the newDatablock to the Item?
                // TODO: Not sure what to do here (16 sept 2017: Remove it, because the pointer cannot be trusted; use the id string)
            }
            text = data.mOutSuccessText.c_str();
            if (text.isEmpty())
                text = QString ("Import completed");
            QMessageBox::information(0, QString("Info"), text);
        }
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while importing");
        QMessageBox::information(0, QString("Error"), text);
    }

    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Perform post-import actions (by the plugin)
    plugin->performPostImportActions();

    // Perform post-import actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_SAVE_RESOURCE_LOCATIONS)
    {
        // Save all resource locations
        HlmsBuilder builder;
        builder.saveAllResourcesLocations();
    }
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_OPEN_PROJECT)
    {
        // Open a project (referered to by means of data.mOutExportReference)
        QString fileName = QString::fromStdString(data.mOutReference);
        if (!fileName.isEmpty())
            loadProject(fileName);
    }
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_OPEN_PROJECT_MAPREF)
    {
        // Open a project (referered to by means of data.mOutReferencesMap)
        QString fileName = getStringPropertyFromReferenceMap ("load_project", &data);
        if (!fileName.isEmpty())
            loadProject(fileName);
    }
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_LOAD_MESH)
    {
        // Load a mesh file
        QString fileName = QString::fromStdString(data.mOutReference);
        if (!fileName.isEmpty())
            loadMesh(fileName);
    }
    if (plugin->getActionFlag() & Ogre::PAF_POST_IMPORT_LOAD_MESH_MAPREF)
    {
        // Load a mesh file
        QString fileName = getStringPropertyFromReferenceMap ("load_mesh", &data);
        if (!fileName.isEmpty())
            loadMesh(fileName);
    }

    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
bool MainWindow::doImportOpenFileDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data)
{
    if (plugin->getActionFlag() & Ogre::PAF_PRE_IMPORT_OPEN_FILE_DIALOG)
    {
        QString fileName;
        fileName = QFileDialog::getOpenFileName(this, QString("Import"),
                                                QString(""),
                                                QString("(*.*)"));

        if (!fileName.isEmpty())
        {
            QFileInfo info(fileName);
            data->mInFileDialogName = info.fileName().toStdString();
            data->mInFileDialogBaseName = info.baseName().toStdString();
            data->mInFileDialogPath = (info.absolutePath() + QString("/")).toStdString();
            data->mInExportPath = data->mInFileDialogPath;
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No file selected"));
            return false;
        }
    }

    return true;
}

//****************************************************************************/
const QString& MainWindow::getStringPropertyFromReferenceMap (const std::string& propertyName, Ogre::HlmsEditorPluginData* data)
{
    std::map<std::string, Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY> outputProperties = data->mOutReferencesMap;
    std::map<std::string, Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY>::iterator it = outputProperties.find(propertyName);
    if (it != outputProperties.end())
    {
        // Property found; return its value
        mTempString = QString::fromStdString((it->second).stringValue);
        Ogre::LogManager::getSingleton().logMessage("Load mesh: " + mTempString.toStdString()); // TEST
        return mTempString;
    }
}

//****************************************************************************/
void MainWindow::doExport(Ogre::HlmsEditorPlugin* plugin)
{
    // Make sure that the materials are not attached to the entity before they are deleted
    detachMaterialsFromItem();

    // Destroy the special datablocks
    destroySpecialDatablocks();

    // Do not destroy special datablocks and destroy all other datablocks, but keep the list with loaded
    // datablocks, although they are destroyed. This list is reused to recreate the datablocks again
    // at the end of this function
    mHlmsUtilsManager->destroyDatablocks(false, true);

    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before export (to select the dir to be exported)?
    if (!doExportOpenFileDialog(plugin, &data))
        return;

    // Is a properties dialog needed before export?
    doImportExportPropertiesDialog (plugin, &data);

    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Are the textures of all datablocks in the material browser needed?
    if (plugin->getActionFlag() & Ogre::PAF_PRE_EXPORT_TEXTURES_USED_BY_DATABLOCK)
    {
        // Reload all datablocks from the material browser
        std::vector<Ogre::String> materials;
        materials = data.mInMaterialFileNameVector;
        std::vector<Ogre::String>::iterator it = materials.begin();
        std::vector<Ogre::String>::iterator itEnd = materials.end();
        Ogre::String fileName = "";
        while (it != itEnd)
        {
            // Load the materials
            fileName = *it;
            if (!fileName.empty())
            {
                mHlmsUtilsManager->loadDatablock(fileName.c_str());
            }
            ++it;
        }

        // Get the texture basenames from the datablocks
        std::vector<Ogre::String> vPbs;
        std::vector<Ogre::String> vUnlit;
        mHlmsUtilsManager->getTexturesFromRegisteredPbsDatablocks(&vPbs);
        mHlmsUtilsManager->getTexturesFromRegisteredUnlitDatablocks(&vUnlit);

        // Add all textures from Pbs
        std::vector<Ogre::String>::iterator itPbs = vPbs.begin();
        std::vector<Ogre::String>::iterator itPbsEnd = vPbs.end();
        Ogre::String baseName;
        while (itPbs != itPbsEnd)
        {
            baseName = *itPbs;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itPbs;
        }

        // Add all textures from Unlit
        std::vector<Ogre::String>::iterator itUnlit = vUnlit.begin();
        std::vector<Ogre::String>::iterator itUnlitEnd = vUnlit.end();
        while (itUnlit != itUnlitEnd)
        {
            baseName = *itUnlit;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itUnlit;
        }
    }

    // Perform pre-export actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_PRE_EXPORT_DELETE_ALL_DATABLOCKS)
        mHlmsUtilsManager->destroyDatablocks(false, true); // Keep the list with loaded datablocks

    // Perform pre-export actions (by the plugin)
    plugin->performPreExportActions();

    // Execute the export
    bool result = plugin->executeExport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        text = data.mOutSuccessText.c_str();
        if (text.isEmpty())
            text = QString ("Export completed");
        QMessageBox::information(0, QString("Info"), text);
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while exporting");
        QMessageBox::information(0, QString("Error"), text);
    }

    // Perform post-export actions (by the plugin)
    plugin->performPostExportActions();

    // Perform post-export actions (by the editor)
    if (plugin->getActionFlag() & Ogre::PAF_POST_EXPORT_DELETE_ALL_DATABLOCKS)
        mHlmsUtilsManager->destroyDatablocks(false, true); // Keep the list with loaded datablocks

    // Recreate the datablocks from the list with datablocks that were loaded at the begin of this function
    mHlmsUtilsManager->reloadNonSpecialDatablocks();

    // Attach the datablocks to the subItems
    restoreMaterialsOfItem();

    // Recreate the special datablocks
    createSpecialDatablocks();
}

//****************************************************************************/
bool MainWindow::doExportOpenFileDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data)
{
    if (plugin->getActionFlag() & Ogre::PAF_PRE_EXPORT_OPEN_DIR_DIALOG)
    {
        QString path;
        QFileDialog dialog;
        dialog.setFileMode(QFileDialog::Directory);
        if (dialog.exec())
        {
            QStringList fileNames = dialog.selectedFiles();
            path = fileNames.at(0);
        }

        if (!path.isEmpty())
        {
            data->mInFileDialogPath = (path + QString("/")).toStdString();
            data->mInExportPath = data->mInFileDialogPath;
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No directory"));
            return false;
        }
    }

    return true;
}

//****************************************************************************/
void MainWindow::doImportExportPropertiesDialog (Ogre::HlmsEditorPlugin* plugin, Ogre::HlmsEditorPluginData* data)
{
    if (plugin->getActionFlag() & Ogre::PAF_PRE_ACTION_SETTINGS_DIALOG)
    {
        // Create the dialog dynamically and fill it with properties from the plugin
        PluginPropertiesDialog dialog (this);
        std::map<std::string, Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY> properties = plugin->getProperties();
        std::map<std::string, Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY>::iterator it;
        std::map<std::string, Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY>::iterator itEnd = properties.end();
        Ogre::HlmsEditorPluginData::PLUGIN_PROPERTY property;
        for (it = properties.begin(); it != itEnd; ++it)
        {
            property = it->second;
            dialog.addProperty(property);
        }

        // Set the (changed) property back in the data object
        if (dialog.exec())
        {
            // Set the values from the dialog back to the data object
            data->mInPropertiesMap = dialog.getProperties();
        }
    }
}

//****************************************************************************/
void MainWindow::constructHlmsEditorPluginData (Ogre::HlmsEditorPluginData* data)
{
    QOgreWidget* widget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    Ogre::Item* item = widget->getItem();
    data->mInItem = item;

    // mInMaterialFileNameVector
    data->mInMaterialFileName = mMaterialFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& materialResources = mMaterialBrowser->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itMaterials(materialResources);
    itMaterials.toFront();
    Magus::QtResourceInfo* info;
    data->mInMaterialFileNameVector.clear();
    while (itMaterials.hasNext())
    {
        // Only add real filenames (assets)
        info = itMaterials.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInMaterialFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    // mInTextureFileNameVector
    data->mInTextureFileName = mTextureFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& textureResources = mTextureDockWidget->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itTextures(textureResources);
    itTextures.toFront();
    data->mInTextureFileNameVector.clear();
    while (itTextures.hasNext())
    {
        // Only add real filenames (assets)
        info = itTextures.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInTextureFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    data->mInOutCurrentDatablock = item->getSubItem(0)->getDatablock();
    data->mInProjectName = mProjectName.toStdString();
    data->mInProjectPath = mProjectPath.toStdString();
    data->mInFileDialogName = "";
    data->mInFileDialogBaseName = "";
    data->mInFileDialogPath = "";

    // Use value from settings.cfg for import path
    QSettings settings(FILE_SETTINGS, QSettings::IniFormat);
    QString importPath = settings.value(SETTINGS_IMPORT_PATH).toString();
    if (importPath.isEmpty())
        importPath = DEFAULT_IMPORT_PATH;
    data->mInImportPath = importPath.toStdString();

    data->mInExportPath = "";
    data->mInRenderWindow = widget->getRenderWindow();
    data->mInSceneManager = widget->getSceneManager();
    data->mInTextureFileName = mTextureFileName.toStdString();
    data->mOutErrorText = "Error while performing this function";
    data->mOutReference = "";
    data->mOutSuccessText = "";
    data->mInTexturesUsedByDatablocks.clear();
}

//****************************************************************************/
void MainWindow::appendRecentMaterialToRecentlyUsed(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentMaterialsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentMaterialsFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentMaterialsFiles.size() > MAX_RECENT_HLMS_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentMaterialsFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentMaterialsFilesMenu->removeAction(action);
        delete action;
        mRecentMaterialsFiles.removeAt(0);
    }

    mRecentMaterialsFiles.append(recentFiles);
    mRecentMaterialsFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentMaterialFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentMaterialFilesCfg();
}

//****************************************************************************/
void MainWindow::appendRecentProjectToRecentlyUsed(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentProjectFiles.size() > MAX_RECENT_PROJECT_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentProjectFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentProjectFilesMenu->removeAction(action);
        delete action;
        mRecentProjectFiles.removeAt(0);
    }

    mRecentProjectFiles.append(recentFiles);
    mRecentProjectFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentProjectFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentProjectFilesCfg();
}

//****************************************************************************/
void MainWindow::doRecentMaterialFileAction(const QString& fileName)
{
    loadMaterialAndCreateNodeStructure(fileName);
}

//****************************************************************************/
void MainWindow::doRecentProjectFileAction(const QString& fileName)
{
    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadRecentMaterialFilesCfg(void)
{
    QFile file(FILE_RECENT_HLMS_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentMaterialToRecentlyUsed(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentMaterialFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentMaterialsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentMaterialsFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_HLMS_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::loadRecentProjectFilesCfg(void)
{
    QFile file(FILE_RECENT_PROJECT_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentProjectToRecentlyUsed(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentProjectFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_PROJECT_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAccepted(const QString& fileName)
{
    // A change is made in the material browser and accepted with ok or double click on an item
    if (!fileName.isEmpty())
        loadMaterialAndCreateNodeStructure(fileName);

    // Save all current settings
    saveMaterialBrowserCfg();
}

//****************************************************************************/
void MainWindow::doMaterialBrowserRejected(void)
{
    loadMaterialBrowserCfg(); // Reverses all changes in the material browser
}

//****************************************************************************/
void MainWindow::doMaterialBrowserClosed(void)
{
    mMaterialBrowserPosition = mMaterialBrowser->pos();
    mMaterialBrowserSize = mMaterialBrowser->size();
}

//****************************************************************************/
void MainWindow::detachMaterialsFromItem (void)
{
    // Make a snaphost of the item's materials and set the default datablock
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->makeSnapshotOfItemMaterials();
    ogreWidget->setDefaultDatablockItem();
}

//****************************************************************************/
void MainWindow::destroySpecialDatablocks(void)
{
    // Destroy the axis, highlight and rtt material
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->destroyLightAxisMaterial();
    ogreWidget->destroyHighlightMaterial();
    ogreWidget->destroyUnlitDatablocksRttHoover();
    ogreWidget->destroyUnlitDatablockRttPaint();
}

//****************************************************************************/
void MainWindow::restoreMaterialsOfItem (void)
{
    // First remove all 'dangling'  datablocks from mItem just in case
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->setDefaultDatablockItem();

    // Restore the snapshot
    ogreWidget->restoreSnapshotOfItemMaterials();
}

//****************************************************************************/
void MainWindow::createSpecialDatablocks (void)
{
    // (Re)create the axis, highlight and rtt material
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->createLightAxisMaterial();
    ogreWidget->createHighlightMaterial();
    ogreWidget->createUnlitDatablocksRttHoover();
    ogreWidget->createUnlitDatablockRttPaint();
}

//****************************************************************************/
void MainWindow::setCurrentDatablockIdAndNameStr(const Ogre::IdString& datablockId, const Ogre::String& nameStr)
{
    mCurrentDatablockNameStr = nameStr;
    mCurrentDatablockId = datablockId;

    // Pass the datablock name to the ogre widget
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setCurrentDatablockId(mCurrentDatablockId);
}

//****************************************************************************/
const Ogre::String& MainWindow::getTextureFileNameOfPbs(const Ogre::IdString& datablockId, Ogre::PbsTextureTypes textureType)
{
    // filename from mHlmsUtilsManager
    mHelperName = mHlmsUtilsManager->getTextureFileNameOfPbs(datablockId, textureType);
    return mHelperName;
}

//****************************************************************************/
void MainWindow::setDatablocksFromMaterialBrowserInItem(void)
{
    // Set the name of the datablocks from the mesh in the item (and load them from the materialbrowser).

    // Check the current mesh and determine which materials it uses (based on its mesh)
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    QMap<unsigned short, Ogre::String> indicesAndNameStrs = ogreWidget->getMaterialNamesFromCurrentMesh();

    // Load all materials, so the relation between the full datablock name and the json filename can be made
    loadAllMaterialsFromMaterialBrowser();

    // Iterate through the map with materialnames/full datablock names and assign the datablocks to the subItems
    QMap <unsigned short, Ogre::String>::iterator it = indicesAndNameStrs.begin();
    QMap <unsigned short, Ogre::String>::iterator itEnd = indicesAndNameStrs.end();
    Ogre::IdString name; // This is the hashed name of the datablock
    Ogre::String nameStr; // This is the full name of the datablock
    unsigned short index;
    HlmsUtilsManager::DatablockStruct datablockStruct;
    while (it != itEnd)
    {
        nameStr = it.value();
        index = it.key();
        datablockStruct = mHlmsUtilsManager->getDatablockStructOfNameStr(nameStr);

        // Only set the datablock in the item if it exists
        if (datablockStruct.type != HLMS_NONE)
        {
            name = datablockStruct.datablockId;
            ogreWidget->setDatablockInSubItem(index, name);
        }

        ++it;
    }
}

//****************************************************************************/
QVector<int> MainWindow::getSubItemIndicesWithDatablockAndReplaceWithDefault(const Ogre::IdString& datablockId)
{
    // Returns a list of subItem indices from the main Item
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    helperIndices = ogreWidget->getSubItemIndicesWithDatablock(datablockId);
    ogreWidget->setDatablockInSubItems(helperIndices, DEFAULT_DATABLOCK_NAME);
    return helperIndices;
}

//****************************************************************************/
void MainWindow::replaceCurrentDatablock(QVector<int> indices, Ogre::IdString datablockId)
{
    QOgreWidget* ogreWidget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    ogreWidget->setDatablockInSubItems(indices, datablockId);
}

//****************************************************************************/
void MainWindow::notifyMaterialChanged (QtProperty* property)
{
    // Create a new datablock
    mNodeEditorDockWidget->generateDatablock();
}

//****************************************************************************/
void MainWindow::clearNamesAndRemovePaintLayers(void)
{
    mCurrentJsonFileName = QString("");
    mCurrentDatablockId = "";
    mCurrentDatablockNameStr = "";
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setCurrentDatablockId(mCurrentDatablockId);
    mPaintLayerDockWidget->newHlmsCreated(); // Needed to delete the paintlayers, because a new Hlms is created
    mRenderwindowDockWidget->clearUndoRedoStackEntry();
}

//****************************************************************************/
PaintLayers* MainWindow::getPaintLayers(void)
{
    return mPaintLayerManager.getPaintLayers();
}

//****************************************************************************/
void MainWindow::setBrushInPaintLayer(const QString& name, const QString& baseName)
{
    mPaintLayerDockWidget->setBrushInPaintLayer(name, baseName);
}

//****************************************************************************/
void MainWindow::loadTextureGeneration (Ogre::PbsTextureTypes textureType, Ogre::ushort sequence)
{
    mPaintLayerManager.loadTextureGeneration (textureType, sequence);
}

//****************************************************************************/
void MainWindow::notifyNodeDeleted(unsigned int nodeType)
{
    switch (nodeType)
    {
        case NODE_TYPE_PBS_DATABLOCK:
            mPropertiesDockWidget->setHlmsPropertiesPbsDatablockVisible(false);
        break;

        case NODE_TYPE_UNLIT_DATABLOCK:
            mPropertiesDockWidget->setHlmsPropertiesUnlitDatablockVisible(false);
        break;

        case NODE_TYPE_SAMPLERBLOCK:
            mPropertiesDockWidget->setHlmsPropertiesSamplerblockVisible(false);
        break;

        case NODE_TYPE_BLENDBLOCK:
            mPropertiesDockWidget->setHlmsPropertiesBlendblockVisible(false);
        break;

        case NODE_TYPE_MACROBLOCK:
            mPropertiesDockWidget->setHlmsPropertiesMacroblockVisible(false);
        break;
    }
}

//****************************************************************************/
void MainWindow::notifyCopiedSamplerblockToClipboard (void)
{
    // Only the current samplerblock is copied
    // Save the properties and put a reference to the samplerblock clipboard (tab) in BrushPresetDockWidget
    QString filename = mPropertiesDockWidget->saveHlmsPropertiesSamplerblock();

    // Add to clipboard
    mBrushPresetDockWidget->addSamplerblockToClipboard(filename);
}

//****************************************************************************/
void MainWindow::notifyCopiedPbsDatablockToClipboard (void)
{
    // TODO
    QString filename = mPropertiesDockWidget->saveHlmsPropertiesPbsDatablock();

    // Add to clipboard
    mBrushPresetDockWidget->addPbsDatablockToClipboard(filename);
}

//****************************************************************************/
bool MainWindow::isSamplerClip(const QString& filename)
{
    return mPropertiesDockWidget->isSamplerProperties(filename);
}

//****************************************************************************/
bool MainWindow::isPbsClip(const QString& filename)
{
    return mPropertiesDockWidget->isPbsProperties(filename);
}

//****************************************************************************/
void MainWindow::useFromClipboard (const QString& fileName)
{
    // Is it a pbs or a sampler?
    if (mPropertiesDockWidget->isSamplerProperties(fileName))
    {
        // Create a new samplerblock in the NodeEditor
        mNodeEditorDockWidget->newSamplerblockNode();

        // Load its properties; the new node is created, has focus and its properties are set and displayed in the mPropertiesDockWidget
        mPropertiesDockWidget->loadHlmsPropertiesSamplerblock(fileName);
    }
    else if (mPropertiesDockWidget->isPbsProperties(fileName))
    {
        // Create a new pbs datablock in the NodeEditor
        mNodeEditorDockWidget->newHlmsPbs();

        // Load its properties; the new node is created, has focus and its properties are set and displayed in the mPropertiesDockWidget
        mPropertiesDockWidget->loadHlmsPropertiesPbsDatablock(fileName);
    }
}

//****************************************************************************/
void MainWindow::deleteTempPathRecursive(void)
{
    // Note, that QDir::removeRecursively exist, but this also deletes the temp directory itself, so use the old way
    QString path = TEMP_PATH.c_str();
    QDir dir(path);
    if (!dir.exists())
    {
        // It doesn't exist, so create it
        QDir().mkdir(path);
        return;
    }

    dir.makeAbsolute();
    Q_FOREACH(QFileInfo info, dir.entryInfoList(QDir::NoDotAndDotDot | QDir::System | QDir::Hidden  | QDir::AllDirs | QDir::Files, QDir::DirsFirst))
    {
        if (!info.isDir())
        {
            if (info.fileName() != "readme.md" && info.fileName() != "README.md" && info.fileName() != "README.MD")
                QFile::remove(info.absoluteFilePath());
        }
    }
}

//****************************************************************************/
void MainWindow::addResourceLocationFile (const QString& fileName)
{
    QFileInfo info(fileName);
    mOgreManager->getOgreRoot()->addResourceLocation(info.absolutePath().toStdString(),
                                                     "FileSystem",
                                                     Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
}

//****************************************************************************/
void MainWindow::addResourceLocationPath (const QString& path)
{
    mOgreManager->getOgreRoot()->addResourceLocation(path.toStdString(),
                                                     "FileSystem",
                                                     Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
}
