/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include "constants.h"
#include "magus_core.h"
#include <QString>
#include <QFile>
#include <QTextStream>
#include <QMenuBar>
#include "mainwindow.h"
#include "OgreRoot.h"
#include "OgrePlugin.h"
#include "OgreMesh.h"
#include "OgreItem.h"
#include "OgreMeshManager.h"
#include "OgreMeshManager2.h"
#include "OgreMeshSerializer.h"
#include "OgreMesh2Serializer.h"
#include "OgreHlmsPbs.h"
#include "OgreHlmsUnlit.h"
#include "OgreHlmsPbsDatablock.h"
#include "OgreHlmsUnlitDatablock.h"
#include "OgreHlmsManager.h"
#include "OgreArchiveManager.h"
#include "hlms_builder.h"
#include "hlms_pbs_builder.h"
#include "hlms_unlit_builder.h"
#include "hlms_editor_plugin.h"
#include "hlms_editor_plugin_action.h"

//****************************************************************************/
MainWindow::MainWindow(void) :
    mIsClosing(false),
    mFirst(true),
    mSaveTextureBrowserTimerActive(false)
{
    installEventFilter(this);

    // Create the Ogre Manager
    mOgreManager = new Magus::OgreManager();
    newProjectName();
    mHlmsName = QString("");
    mTempString = QString("");
    mTempOgreString = "";
    
	// Perform standard functions
    createActions();
    createMenus();
    createToolBars();
    createStatusBar();
    createDockWindows();
    mMaterialBrowser = new MaterialBrowserDialog(this);
    connect(mMaterialBrowser, SIGNAL(okClicked(QString)), this, SLOT(doMaterialBrowserAccepted(QString)));
    connect(mMaterialBrowser, SIGNAL(cancelClicked()), this, SLOT(doMaterialBrowserRejected()));
    connect(mMaterialBrowser, SIGNAL(closeClicked()), this, SLOT(doMaterialBrowserClosed()));
    loadMaterialBrowserCfg();
    loadTextureBrowserCfg();
    loadRecentHlmsFilesCfg();
    loadRecentProjectFilesCfg();
    mOgreManager->initialize();

    // Disable shaderfile generation
    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
    hlmsPbs->setDebugOutputPath(false);
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));
    hlmsUnlit->setDebugOutputPath(false);

    // Set the title
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);

    // Set the stylesheet of the application
    QFile File(QString("dark.qss"));
    File.open(QFile::ReadOnly);
    QString styleSheet = QLatin1String(File.readAll());
    setStyleSheet(styleSheet);
	showMaximized();
}

//****************************************************************************/
MainWindow::~MainWindow(void)
{
    delete mOgreManager;
}

//****************************************************************************/
bool MainWindow::eventFilter(QObject* object, QEvent* event)
{
    if (event->type()==QEvent::KeyPress)
    {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if (key->key() == Qt::Key_F5)
        {
            // F5 was pressed
            mNodeEditorDockWidget->generateDatablock();
        }
        if (key->key() == Qt::Key_S && (QApplication::keyboardModifiers() & Qt::ControlModifier))
        {
            // CTRL+S was pressed
            doSaveDatablockMenuAction();
        }
    }
    return QObject::eventFilter(object, event);
}

//****************************************************************************/
void MainWindow::closeEvent(QCloseEvent* event)
{
    mIsClosing = true;
}

//****************************************************************************/
void MainWindow::createActions(void)
{
    // ******** File menu ********
    // New
    mNewProjectAction = new QAction(QString("New Project"), this);
    mNewProjectAction->setShortcut(QKeySequence(QString("Ctrl+Shift+N")));
    connect(mNewProjectAction, SIGNAL(triggered()), this, SLOT(doNewProjectAction()));
    mNewHlmsPbsAction = new QAction(QString("New Hlms Pbs"), this);
    mNewHlmsPbsAction->setShortcut(QKeySequence(QString("Ctrl+Alt+N")));
    connect(mNewHlmsPbsAction, SIGNAL(triggered()), this, SLOT(doNewHlmsPbsAction()));
    mNewHlmsUnlitAction = new QAction(QString("New Hlms Unlit"), this);
    mNewHlmsUnlitAction->setShortcut(QKeySequence(QString("Ctrl+N")));
    connect(mNewHlmsUnlitAction, SIGNAL(triggered()), this, SLOT(doNewHlmsUnlitAction()));

    // Open
    mOpenProjectMenuAction = new QAction(QString("Open Project"), this);
    mOpenProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+O")));
    connect(mOpenProjectMenuAction, SIGNAL(triggered()), this, SLOT(doOpenProjectMenuAction()));
    mOpenDatablockMenuAction = new QAction(QString("Open Hlms"), this);
    mOpenDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+O")));
    connect(mOpenDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doOpenDatablockMenuAction()));
    mOpenModelMenuAction = new QAction(QString("Open Mesh"), this);
    mOpenModelMenuAction->setShortcut(QKeySequence(QString("Ctrl+O")));
    connect(mOpenModelMenuAction, SIGNAL(triggered()), this, SLOT(doOpenModelMenuAction()));

    // Save
    mSaveProjectMenuAction = new QAction(QString("Save Project"), this);
    mSaveProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+S")));
    connect(mSaveProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveProjectMenuAction()));
    mSaveDatablockMenuAction = new QAction(QString("Save Hlms"), this);
    mSaveDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+S")));
    connect(mSaveDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveDatablockMenuAction()));

    // Save as
    mSaveAsProjectMenuAction = new QAction(QString("Save Project as"), this);
    mSaveAsProjectMenuAction->setShortcut(QKeySequence(QString("Ctrl+Shift+A")));
    connect(mSaveAsProjectMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsProjectMenuAction()));
    mSaveAsDatablockMenuAction = new QAction(QString("Save Hlms as"), this);
    mSaveAsDatablockMenuAction->setShortcut(QKeySequence(QString("Ctrl+Alt+A")));
    connect(mSaveAsDatablockMenuAction, SIGNAL(triggered()), this, SLOT(doSaveAsDatablockMenuAction()));

    // Quit
    mQuitMenuAction = new QAction(QString("Quit"), this);
    mQuitMenuAction->setShortcut(QKeySequence(QString("Ctrl+Q")));
    connect(mQuitMenuAction, SIGNAL(triggered()), this, SLOT(doQuitMenuAction()));

    // ******** Materials menu ********
    mMaterialBrowserOpenMenuAction = new QAction(QString("Open browser"), this);
    mMaterialBrowserOpenMenuAction->setShortcut(QKeySequence(QString("Ctrl+B")));
    connect(mMaterialBrowserOpenMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserOpenMenuAction()));
    mMaterialBrowserAddMenuAction = new QAction(QString("Add Hlms to browser"), this);
    mMaterialBrowserAddMenuAction->setShortcut(QKeySequence(QString("Ctrl+H")));
    connect(mMaterialBrowserAddMenuAction, SIGNAL(triggered()), this, SLOT(doMaterialBrowserAddMenuAction()));

    // ******** Texture menu ********
    mTextureBrowserImportMenuAction = new QAction(QString(ACTION_IMPORT_TEXTURES_FROM_DIR), this);
    mTextureBrowserImportMenuAction->setShortcut(QKeySequence(QString("Ctrl+I")));
    connect(mTextureBrowserImportMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserImportMenuAction()));
    mTextureBrowserAddImageMenuAction = new QAction(QString(ACTION_ADD_TEXTURES), this);
    mTextureBrowserAddImageMenuAction->setShortcut(QKeySequence(QString("Ctrl+T")));
    connect(mTextureBrowserAddImageMenuAction, SIGNAL(triggered()), this, SLOT(doTextureBrowserAddImageMenuAction()));

    // ******** Window menu ********
    mResetWindowLayoutMenuAction = new QAction(QString("Reset Window Layout"), this);
    mResetWindowLayoutMenuAction->setShortcut(QKeySequence(QString("Ctrl+R")));
    connect(mResetWindowLayoutMenuAction, SIGNAL(triggered()), this, SLOT(doResetWindowLayoutMenuAction()));
}

//****************************************************************************/
void MainWindow::createMenus(void)
{
    // ******** File ********
    mFileMenu = menuBar()->addMenu(QString("&File"));
    mMaterialBrowserMenu = menuBar()->addMenu(QString("&Materials"));
    mTextureBrowserMenu = menuBar()->addMenu(QString("&Textures"));
    QMenu* fileMenuAction = mFileMenu->addMenu("New");

    // New
    fileMenuAction->addAction(mNewProjectAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mNewHlmsPbsAction);
    fileMenuAction->addAction(mNewHlmsUnlitAction);

    // Open
    fileMenuAction = mFileMenu->addMenu("Open");
    fileMenuAction->addAction(mOpenProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenDatablockMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mOpenModelMenuAction);

    // Save
    fileMenuAction = mFileMenu->addMenu("Save");
    fileMenuAction->addAction(mSaveProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveDatablockMenuAction);

    // Save as
    fileMenuAction = mFileMenu->addMenu("Save as");
    fileMenuAction->addAction(mSaveAsProjectMenuAction);
    fileMenuAction->addSeparator();
    fileMenuAction->addAction(mSaveAsDatablockMenuAction);

    // Import/Export
    Ogre::Root::PluginInstanceList plugins = mOgreManager->getOgreRoot()->getInstalledPlugins();
    Ogre::Root::PluginInstanceList::iterator it;
    Ogre::Root::PluginInstanceList::iterator itStart = plugins.begin();
    Ogre::Root::PluginInstanceList::iterator itEnd = plugins.end();
    Ogre::Plugin* plugin;
    PluginAction* action;
    bool menuImportExists = false;
    bool menuExportExists = false;
    for (it = itStart; it != itEnd; ++it)
    {
        plugin = *it;
        if (plugin->getName() == GENERAL_HLMS_PLUGIN_NAME)
        {
            // It is a Hlms editor plugin
            Ogre::HlmsEditorPlugin* hlmsEditorPlugin = dynamic_cast<Ogre::HlmsEditorPlugin*>(plugin);
            if (hlmsEditorPlugin->isImport())
            {
                // First create an import menu item if needed
                if (!menuImportExists)
                {
                    fileMenuAction = mFileMenu->addMenu("Import");
                    menuImportExists = true;
                }

                // Add the import action of the plugin to the submenu
                action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getImportMenuText().c_str(), this);
                connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doImport(Ogre::HlmsEditorPlugin*)));
                fileMenuAction->addAction(action);
            }
            if (hlmsEditorPlugin->isExport())
            {
                // First create an export menu item if needed
                if (!menuExportExists)
                {
                    fileMenuAction = mFileMenu->addMenu("Export");
                    menuExportExists = true;
                }

                // Add the export action of the plugin to the submenu
                action = new PluginAction(hlmsEditorPlugin, hlmsEditorPlugin->getExportMenuText().c_str(), this);
                connect(action, SIGNAL(pluginActionTriggered(Ogre::HlmsEditorPlugin*)), this, SLOT(doExport(Ogre::HlmsEditorPlugin*)));
                fileMenuAction->addAction(action);
            }
        }
    }

    // Recent Hlms files
    mRecentHlmsFilesMenu = mFileMenu->addMenu("Recent Hlms files");

    // Recent Hlms files
    mRecentProjectFilesMenu = mFileMenu->addMenu("Recent Project files");

    // Quit
    mFileMenu->addAction(mQuitMenuAction);

    // ******** Material browser ********
    mMaterialBrowserMenu->addAction(mMaterialBrowserOpenMenuAction);
    mMaterialBrowserMenu->addAction(mMaterialBrowserAddMenuAction);

    // ******** Texture browser ********
    mTextureBrowserMenu->addAction(mTextureBrowserImportMenuAction);
    mTextureBrowserMenu->addAction(mTextureBrowserAddImageMenuAction);

    // ******** Window ********
    mWindowMenu = menuBar()->addMenu(QString("&Window"));
    mWindowMenu->addAction(mResetWindowLayoutMenuAction);
}

//****************************************************************************/
void MainWindow::createToolBars(void)
{

}

//****************************************************************************/
void MainWindow::createStatusBar(void)
{

}

//****************************************************************************/
void MainWindow::createDockWindows(void)
{
    mRenderwindowDockWidget = new RenderwindowDockWidget("Renderwindow", this);
    addDockWidget(Qt::LeftDockWidgetArea, mRenderwindowDockWidget);
    mPropertiesDockWidget = new PropertiesDockWidget("Properties", this);
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);

    mTextureDockWidget = new TextureDockWidget("Textures", this);
    addDockWidget(Qt::RightDockWidgetArea, mTextureDockWidget);
    mNodeEditorDockWidget = new NodeEditorDockWidget("NodeEditor", this);
    addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);
    connect(mTextureDockWidget, SIGNAL(textureDoubleClicked(QString,QString)), this, SLOT(handleTextureDoubleClicked(QString,QString)));
    connect(mTextureDockWidget, SIGNAL(customContextMenuItemSelected(QString)), this, SLOT(handleCustomContextMenuItemSelected(QString)));
    connect(mTextureDockWidget, SIGNAL(textureMutationOccured()), this, SLOT(handleTextureMutationOccured()));
}

//****************************************************************************/
void MainWindow::doNewProjectAction(void)
{
    mMaterialBrowser->clearResources();
    mTextureDockWidget->clearResources();
    newProjectName();
    clearDatablocks();
}

//****************************************************************************/
void MainWindow::newProjectName(void)
{
    mProjectName = DEFAULT_PROJECT_NAME;
    mProjectPath = PROJECT_PATH;
    setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
}

//****************************************************************************/
void MainWindow::doNewHlmsPbsAction(void)
{
    initDatablocks();
    mPropertiesDockWidget->clear();
    mNodeEditorDockWidget->newHlmsPbs();
}

//****************************************************************************/
void MainWindow::doNewHlmsUnlitAction(void)
{
    initDatablocks();
    mPropertiesDockWidget->clear();
    mNodeEditorDockWidget->newHlmsUnlit();
}

//****************************************************************************/
void MainWindow::clearDatablocks(void)
{
    initDatablocks();
    mPropertiesDockWidget->clear();
    mNodeEditorDockWidget->clear();
}

//****************************************************************************/
void MainWindow::doOpenProjectMenuAction(void)
{
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Load the Project"),
                                            QString(""),
                                            QString("Hlms Project file (*.hlmp)"));

    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadProject(const QString& fileName)
{
    QApplication::setOverrideCursor(Qt::WaitCursor);
    if (!fileName.isEmpty())
    {
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");

        QFile file(mProjectPath + mProjectName + QString(".hlmp"));
        QString header;
        if (file.open(QFile::ReadOnly))
        {
            QTextStream readFile(&file);

            // Line 1
            header = readFile.readLine();
            if (header != HEADER_PROJECT)
            {
                QMessageBox::information(0, QString("Error"), QString("This is not a valid Project file"));
            }
            else
            {
                // Line 2
                QString materialFileName = readFile.readLine();
                info.setFile(materialFileName);
                if (info.exists() && info.isFile())
                    mMaterialFileName = materialFileName;

                // Line 3
                QString textureFileName = readFile.readLine();
                info.setFile(textureFileName);
                if (info.exists() && info.isFile())
                    mTextureFileName = textureFileName;

                // Load the material and texture config
                loadMaterialBrowserCfg();
                loadTextureBrowserCfg();
                file.close();
                setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
                appendRecentProject(fileName);
                clearDatablocks();
            }
        }
    }
    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doOpenDatablockMenuAction(void)
{
    // Load the materials
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Hlms file"),
                                            QString(""),
                                            QString("Json material (*.json)"));
    loadDatablockAndSet(fileName);
}

//****************************************************************************/
void MainWindow::loadDatablockAndSet(const QString jsonFileName)
{
    HlmsBuilder builder;
    initDatablocks();
    mPropertiesDockWidget->clear();
    if (loadDatablock(jsonFileName))
    {
        mHlmsName = jsonFileName;
        appendRecentHlms(jsonFileName);

        // Get the (list of) datablocks and assign the first one to the current 'item' to be rendered
        getAndSetFirstDatablock();
    }
    else
    {
        Ogre::LogManager::getSingleton().logMessage("MainWindow::doOpenDatablockMenuAction(); Could not load the materials\n");
    }
}

//****************************************************************************/
void MainWindow::doOpenModelMenuAction(void)
{
    // Load a model
    QString fileName;
    fileName = QFileDialog::getOpenFileName(this, QString("Open Model"),
                                            QString(""),
                                            QString("MESH (*.mesh);;"
                                                    "All files (*.*)"));
    if (!fileName.isEmpty())
        loadModel(fileName);
}

//****************************************************************************/
void MainWindow::loadModel(const QString modelFileName)
{
    if (!Magus::fileExist(modelFileName))
    {
        QMessageBox::information(0, QString("Warning"), modelFileName + QString(" does not exist."));
        return;
    }

    // 1. Model is an Ogre mesh?
    QFileInfo info(modelFileName);
    QString suffix = info.suffix();
    QString baseName = info.fileName();
    if (suffix != "mesh")
    {
        // Only Ogre3d meshes allowed for now
        QMessageBox::information(0, QString("Warning"), modelFileName + QString(" is not an Ogre3d mesh file."));
        return;
    }

    // 2. Check mesh version
    Ogre::String dataFolder = info.path().toStdString();
    if (isMeshV1 (modelFileName))
    {
        try
        {
            // Add the resource location first
            mOgreManager->getOgreRoot()->addResourceLocation(dataFolder, "FileSystem", "General");

            // Convert v1 mesh to v2 mesh
            Ogre::MeshPtr v2MeshPtr = convertMeshV1ToV2(baseName);

            // Create an item and add it to the renderwindow
            Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
            Ogre::Item* item = sceneManager->createItem(v2MeshPtr, Ogre::SCENE_DYNAMIC);
            mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setItem(item, Ogre::Vector3::UNIT_SCALE);

            // Save the V2 mesh (ask whether it must be saved)
            QMessageBox::StandardButton reply;
            reply = QMessageBox::question(this, "Info", modelFileName +
                                          QString(" is converted to a V2 mesh. Do you want to save it?"),
                                          QMessageBox::Yes|QMessageBox::No);
            if (reply == QMessageBox::Yes)
            {
                // Save the mesh
                QString fileName = QFileDialog::getSaveFileName(this,
                                                                QString("Save the mesh"),
                                                                info.path() + QString("/.mesh"),
                                                                QString("V2 mesh file (*.mesh)"));

                if (!fileName.isEmpty())
                    saveV2Mesh(v2MeshPtr, fileName);
            }

            // Add to mesh map
            mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));

            return;
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Error while converting V1 mesh ") + modelFileName);
        }
    }
    if (isMeshV2 (modelFileName))
    {
        // 3. Load the V2 mesh
        try
        {
            // Add the resource location first
            mOgreManager->getOgreRoot()->addResourceLocation(dataFolder, "FileSystem", "General");

            // Create the mesh and add it to the render window
            mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->createItem(baseName.toStdString(), Ogre::Vector3::UNIT_SCALE);

            // Add to mesh map
            mRenderwindowDockWidget->addToMeshMap(baseName, baseName, QVector3D(1.0f, 1.0f, 1.0f));
        }
        catch (Ogre::Exception e)
        {
            QMessageBox::information(0, QString("Warning"), QString("Cannot load ") + modelFileName);
        }
    }
}

//****************************************************************************/
void MainWindow::saveV2Mesh(Ogre::MeshPtr v2MeshPtr, QString modelFileName)
{
    Ogre::MeshSerializer meshSerializer( 0 );
    meshSerializer.exportMesh(v2MeshPtr.get(), modelFileName.toStdString());
}

//****************************************************************************/
bool MainWindow::isMeshV1(const QString modelFileName)
{
    Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
    if (!sceneManager)
        return false;

    Ogre::v1::MeshPtr v1MeshPtr;
    try
    {
        Ogre::v1::MeshSerializer meshSerializer;
        Ogre::DataStreamPtr stream(openFile(modelFileName.toStdString()));
        Ogre::String name = Ogre::StringConverter::toString(mOgreManager->getOgreRoot()->getTimer()->getMicroseconds());
        v1MeshPtr = Ogre::v1::MeshManager::getSingleton().createManual(name, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
        meshSerializer.importMesh(stream, v1MeshPtr.get());
        v1MeshPtr->unload();
    }
    catch (Ogre::Exception e)
    {
        return false;
    }

    return true;
}

//****************************************************************************/
bool MainWindow::isMeshV2(const QString modelFileName)
{
    Ogre::SceneManager* sceneManager = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getSceneManager();
    if (!sceneManager)
        return false;

    Ogre::MeshPtr v2MeshPtr;
    try
    {
        Ogre::RenderSystem* renderSystem = mOgreManager->getOgreRoot()->getRenderSystem();
        Ogre::VaoManager* vaoManager = renderSystem->getVaoManager();
        Ogre::MeshSerializer meshSerializer(vaoManager);
        Ogre::DataStreamPtr stream(openFile(modelFileName.toStdString()));
        Ogre::String name = Ogre::StringConverter::toString(mOgreManager->getOgreRoot()->getTimer()->getMicroseconds());
        v2MeshPtr = Ogre::MeshManager::getSingleton().createManual(name, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
        meshSerializer.importMesh(stream, v2MeshPtr.get());
        v2MeshPtr->unload();
    }
    catch (Ogre::Exception e)
    {
        return false;
    }

    return true;
}

//****************************************************************************/
Ogre::MeshPtr MainWindow::convertMeshV1ToV2(const QString baseNameMeshV1)
{
    Ogre::v1::MeshPtr v1MeshPtr;
    Ogre::MeshPtr v2MeshPtr;

    // Create V1 mesh
    v1MeshPtr = Ogre::v1::MeshManager::getSingleton().load(
                baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,
                Ogre::v1::HardwareBuffer::HBU_STATIC, Ogre::v1::HardwareBuffer::HBU_STATIC);

    // Create V2 mesh
    v2MeshPtr = Ogre::MeshManager::getSingleton().createManual(baseNameMeshV1.toStdString(), Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );
    v2MeshPtr->importV1 (v1MeshPtr.get(), true, true, true);
    v1MeshPtr->unload();
    return v2MeshPtr;
}


//****************************************************************************/
Ogre::DataStreamPtr MainWindow::openFile(Ogre::String source)
{
    struct stat tagStat;

    FILE* pFile = fopen( source.c_str(), "rb" );
    if (!pFile)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    stat( source.c_str(), &tagStat );
    Ogre::MemoryDataStream* memstream = new Ogre::MemoryDataStream(source, tagStat.st_size, true);
    size_t result = fread( (void*)memstream->getPtr(), 1, tagStat.st_size, pFile );
    if (result != tagStat.st_size)
        OGRE_EXCEPT(Ogre::Exception::ERR_INVALID_STATE, "", "");

    fclose( pFile );
    return Ogre::DataStreamPtr( memstream );
}

//****************************************************************************/
void MainWindow::destroyAllDatablocks(void)
{
    // Get the datablock from the item and remove it
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->setDefaultDatablockItem();
    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));

    // Iterate through all pbs datablocks and remove them
    Ogre::Hlms::HlmsDatablockMap::const_iterator itorPbs = hlmsPbs->getDatablockMap().begin();
    Ogre::Hlms::HlmsDatablockMap::const_iterator endPbs  = hlmsPbs->getDatablockMap().end();
    Ogre::HlmsPbsDatablock* pbsDatablock;
    while( itorPbs != endPbs)
    {
        pbsDatablock = static_cast<Ogre::HlmsPbsDatablock*>(itorPbs->second.datablock);
        if (pbsDatablock != hlmsPbs->getDefaultDatablock() &&
                pbsDatablock != hlmsUnlit->getDefaultDatablock() &&
                pbsDatablock->getName() != Magus::AXIS_MATERIAL_NAME)
        {
            hlmsPbs->destroyDatablock(pbsDatablock->getName());
            itorPbs = hlmsPbs->getDatablockMap().begin(); // Start from the beginning again
        }
        else
            ++itorPbs;
    }

    // Iterate through all unlit datablocks and remove them
    Ogre::Hlms::HlmsDatablockMap::const_iterator itorUnlit = hlmsUnlit->getDatablockMap().begin();
    Ogre::Hlms::HlmsDatablockMap::const_iterator endUnlit  = hlmsUnlit->getDatablockMap().end();
    Ogre::HlmsUnlitDatablock* unlitDatablock;
    while( itorUnlit != endUnlit)
    {
        unlitDatablock = static_cast<Ogre::HlmsUnlitDatablock*>(itorUnlit->second.datablock);
        if (unlitDatablock != hlmsPbs->getDefaultDatablock() &&
                unlitDatablock != hlmsUnlit->getDefaultDatablock() &&
                unlitDatablock->getName() != Magus::AXIS_MATERIAL_NAME)
        {
            hlmsUnlit->destroyDatablock(unlitDatablock->getName());
            itorUnlit = hlmsUnlit->getDatablockMap().begin(); // Start from the beginning again
        }
        else
            ++itorUnlit;
    }
}


//****************************************************************************/
void MainWindow::getAndSetFirstDatablock(void)
{
    // Get the name/fullname from the current item in the renderwindow
    Ogre::Item* item = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->getItem();
    Ogre::HlmsDatablock* oldDatablock = item->getSubItem(0)->getDatablock();
    Ogre::String oldDatablockName = *oldDatablock->getFullName();
    Ogre::IdString oldDatablockId = oldDatablock->getName();

    // Determine whether the HlmsManager contains a HLMS_PBS datablock or a HLMS_UNLIT datablock.
    // Depending on the result, the datablock of that type is retrieved and set in the mesh (item).
    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS));
    Ogre::HlmsUnlit* hlmsUnlit = static_cast<Ogre::HlmsUnlit*>( hlmsManager->getHlms(Ogre::HLMS_UNLIT));

    if (hlmsPbs)
    {
        int size = hlmsPbs->getDatablockMap().size();
        if (size> 2)
        {
            // It is a PBS; Note, that there is also a default and the pbs material of the light axis (so always 2)
            Ogre::Hlms::HlmsDatablockMap::const_iterator itor = hlmsPbs->getDatablockMap().begin();
            Ogre::Hlms::HlmsDatablockMap::const_iterator end  = hlmsPbs->getDatablockMap().end();
            Ogre::HlmsPbsDatablock* newDatablock;
            Ogre::String newDatablockName;
            while( itor != end )
            {
                newDatablock = static_cast<Ogre::HlmsPbsDatablock*>(itor->second.datablock);
                if (newDatablock != hlmsPbs->getDefaultDatablock() &&
                        newDatablock != hlmsUnlit->getDefaultDatablock() &&
                        newDatablock->getName() != Magus::AXIS_MATERIAL_NAME)
                {
                    // Get the first datablock
                    newDatablockName = *newDatablock->getFullName();
                    if (oldDatablockName != newDatablockName)
                    {
                        // Assign the datablock to the item (and destroy the items' old datablock, if still available)
                        item->setDatablock(newDatablock);
                        if (oldDatablock != hlmsPbs->getDefaultDatablock() &&
                                oldDatablock != hlmsUnlit->getDefaultDatablock() &&
                                oldDatablock->getName() != Magus::AXIS_MATERIAL_NAME)
                        {
                            if (oldDatablock->getCreator()->getType() == Ogre::HLMS_PBS)
                                hlmsPbs->destroyDatablock(oldDatablockId);
                            else if (hlmsUnlit && oldDatablock->getCreator()->getType() == Ogre::HLMS_UNLIT)
                                hlmsUnlit->destroyDatablock(oldDatablockId);
                        }

                        // Create the node structure
                        QString s = newDatablockName.c_str();
                        HlmsNodePbsDatablock* node = mNodeEditorDockWidget->createPbsNodeStructure(s);
                        if (node)
                        {
                            node->setSelected(true);
                            mNodeEditorDockWidget->nodeSelected(node);
                        }
                        mPropertiesDockWidget->setTextureTypePropertyVisible(true);
                        mPropertiesDockWidget->setDetailMapPropertiesVisible(true);
                        break;
                    }
                }
                ++itor;
            }
            return;
        }
    }

    if (hlmsUnlit)
    {
        int size = hlmsUnlit->getDatablockMap().size();
        if (size > 1)
        {
            // It is an Unlit; Note, that there is also a default (so always 1)
            Ogre::Hlms::HlmsDatablockMap::const_iterator itor = hlmsUnlit->getDatablockMap().begin();
            Ogre::Hlms::HlmsDatablockMap::const_iterator end  = hlmsUnlit->getDatablockMap().end();
            Ogre::HlmsUnlitDatablock* newDatablock;
            Ogre::String newDatablockName;
            while( itor != end )
            {
                newDatablock = static_cast<Ogre::HlmsUnlitDatablock*>(itor->second.datablock);
                if (newDatablock != hlmsPbs->getDefaultDatablock() && newDatablock != hlmsUnlit->getDefaultDatablock())
                {
                    // Get the first datablock
                    newDatablockName = *newDatablock->getFullName();
                    if (oldDatablockName != newDatablockName)
                    {
                        // Assign the datablock to the item (and destroy the items' old datablock, if still available)
                        item->setDatablock(newDatablock);
                        if (oldDatablock != hlmsPbs->getDefaultDatablock() && oldDatablock != hlmsUnlit->getDefaultDatablock())
                        {
                            if (oldDatablock->getCreator()->getType() == Ogre::HLMS_UNLIT)
                                hlmsUnlit->destroyDatablock(oldDatablockId);
                            else if (hlmsPbs && oldDatablock->getCreator()->getType() == Ogre::HLMS_PBS)
                                hlmsPbs->destroyDatablock(oldDatablockId);
                        }

                        // Create the node structure
                        QString s = newDatablockName.c_str();
                        HlmsNodeUnlitDatablock* node = mNodeEditorDockWidget->createUnlitNodeStructure(s);
                        if (node)
                        {
                            node->setSelected(true);
                            mNodeEditorDockWidget->nodeSelected(node);
                        }
                        mPropertiesDockWidget->setTextureTypePropertyVisible(false);
                        mPropertiesDockWidget->setDetailMapPropertiesVisible(false);
                        break;
                    }
                }
                ++itor;
            }
            return;
        }
    }
}

//****************************************************************************/
void MainWindow::getListOfResources(void)
{
    Ogre::ResourceGroupManager::ResourceManagerIterator it =
        Ogre::ResourceGroupManager::getSingletonPtr()->getResourceManagerIterator();
    while (it.hasMoreElements())
    {
        Ogre::ResourceManager* man = it.getNext();
        Ogre::LogManager::getSingleton().logMessage("Resource Type = " + man->getResourceType());
        Ogre::ResourceManager::ResourceMapIterator mapit = man->getResourceIterator() ;
        while (mapit.hasMoreElements())
        {
            Ogre::ResourcePtr ptr = mapit.getNext();
            Ogre::LogManager::getSingleton().logMessage("Resource Name = " + ptr->getName());
        }
    }
}

//****************************************************************************/
void MainWindow::doSaveProjectMenuAction(void)
{
    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Save material config
    mMaterialFileName = mProjectPath + mProjectName + QString ("_") + FILE_MATERIAL_BROWSER;
    saveMaterialBrowserCfg();

    // Save texture config
    mTextureFileName = mProjectPath + mProjectName + QString ("_") + FILE_TEXTURE_BROWSER;
    saveTextureBrowserCfg();

    // Save a project file
    QString fileName = mProjectPath + mProjectName + QString(".hlmp");
    QFile file(fileName);
    QString header = QString(HEADER_PROJECT);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        stream << header
               << "\n"
               << mMaterialFileName
               << "\n"
               << mTextureFileName
               << "\n";
        file.close();

        // Set title
        setWindowTitle(WINDOW_TITLE + QString (" - ") + mProjectName);
        appendRecentProject(fileName);
    }
    QApplication::restoreOverrideCursor();
}

//****************************************************************************/
void MainWindow::doSaveAsProjectMenuAction(void)
{
    // Save the project file
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    QString("Save the Project"),
                                                    mProjectName + QString(".hlmp"),
                                                    QString("Hlms Project file (*.hlmp)"));

    if (!fileName.isEmpty())
    {
        QFileInfo info(fileName);
        mProjectName = info.baseName();
        mProjectPath = info.absolutePath() + QString("/");
        doSaveProjectMenuAction();
    }
}

//****************************************************************************/
void MainWindow::doSaveDatablockMenuAction(void)
{
    if (mHlmsName.isEmpty())
        doSaveAsDatablockMenuAction();
    else
        saveDatablock();
}

//****************************************************************************/
void MainWindow::doSaveAsDatablockMenuAction(void)
{
    // Get hlms name
    mHlmsName = QString(mNodeEditorDockWidget->getCurrentDatablockName());
    mHlmsName = mHlmsName + QString(".material.json");
    QString fileName = mHlmsName;

    // Save all datablocks to one file
    fileName = QFileDialog::getSaveFileName(this,
                                            QString("Save the Hlms"),
                                            mHlmsName,
                                            QString("Json material (*.json)"));

    if (!fileName.isEmpty())
    {
        mHlmsName = fileName;
        saveDatablock();
    }
}

//****************************************************************************/
bool MainWindow::loadDatablock(const QString& jsonFileName)
{
    bool success = false;

    if (!jsonFileName.isEmpty())
    {
        // Read the json file as text file and feed it to the HlmsManager::loadMaterials() function
        // Note, that the resources (textures, etc.) must be present
        success = true;
        Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
        QFile file(jsonFileName);
        file.open(QFile::ReadOnly | QFile::Text);
        QTextStream readFile(&file);
        QString jsonString = readFile.readAll();
        QByteArray ba = jsonString.toLatin1();
        char* jsonChar = ba.data();
        Ogre::String fname = jsonFileName.toStdString();
        Ogre::HlmsJson hlmsJson(hlmsManager);
        try
        {
            // Load the datablocks (which also creates them)
            hlmsJson.loadMaterials(fname, jsonChar);
        }

        catch (Ogre::Exception e)
        {
            success = false;
        }
        file.close();
    }

    return success;
}

//****************************************************************************/
void MainWindow::saveDatablock(void)
{
    Ogre::String fname = mHlmsName.toStdString();
    QString baseNameJson = mHlmsName;
    baseNameJson = getBaseFileName(baseNameJson);
    QString thumb = baseNameJson + ".png";
    mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());

    Ogre::HlmsManager* hlmsManager = mOgreManager->getOgreRoot()->getHlmsManager();
    if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_PBS)
    {
        hlmsManager->saveMaterials (Ogre::HLMS_PBS, fname);
        mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_PBS);
        appendRecentHlms(mHlmsName);
    }
    else if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_UNLIT)
    {
        hlmsManager->saveMaterials (Ogre::HLMS_UNLIT, fname);
        mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_UNLIT);
        appendRecentHlms(mHlmsName);
    }
}

//****************************************************************************/
void MainWindow::loadMaterialBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mMaterialFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_PBS &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_PBS_DATABLOCK_SMALL_NO_PATH;

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_UNLIT &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_UNLIT_DATABLOCK_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel items
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_PBS;
             info->resourceName = QString("PBS");
             info->fullQualifiedName = QString("PBS");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_PBS_DATABLOCK_NO_PATH;
             resources.append(info);

             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_UNLIT;
             info->resourceName = QString("Unlit");
             info->fullQualifiedName = QString("Unlit");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_UNLIT_DATABLOCK_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mMaterialBrowser->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doQuitMenuAction(void)
{
    close();
}

//****************************************************************************/
void MainWindow::doMaterialBrowserOpenMenuAction(void)
{
    mMaterialBrowser->move(mMaterialBrowserPosition);
    mMaterialBrowser->resize(mMaterialBrowserSize);
    mMaterialBrowser->showNormal();
    mMaterialBrowser->raise();
}

//****************************************************************************/
void MainWindow::saveMaterialBrowserCfg(void)
{
    // Save all current settings
    const QVector<Magus::QtResourceInfo*>& resources = mMaterialBrowser->getResources();
    saveResources(mMaterialFileName, resources);
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAddMenuAction(void)
{
    if (mHlmsName.isEmpty())
        QMessageBox::information(0, QString("Error"), QString("No filename. The Hlms must be saved first"));
    else
    {
        QString baseNameJson = mHlmsName;
        baseNameJson = getBaseFileName(baseNameJson);
        QString thumb = baseNameJson + ".png";
        mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW)->saveToFile(THUMBS_PATH + thumb.toStdString());

        if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_PBS)
            mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_PBS);
        else if (getCurrentDatablockType() == EditorHlmsTypes::HLMS_UNLIT)
            mMaterialBrowser->addMaterial(baseNameJson, mHlmsName, thumb, HLMS_UNLIT);

        saveMaterialBrowserCfg();
    }
}

//****************************************************************************/
void MainWindow::doTextureBrowserImportMenuAction(void)
{
    QString textureFolder;
    QFileDialog dialog;
    dialog.setFileMode(QFileDialog::Directory);
    if (dialog.exec())
    {
        QStringList fileNames = dialog.selectedFiles();
        textureFolder = fileNames.at(0);

        // Add all texture files to a group in mTextureDockWidget
        //QString path;
        QString fileName;

        QDirIterator dirIt(textureFolder, QDirIterator::Subdirectories);
        while (dirIt.hasNext())
        {
            dirIt.next();
            if (QFileInfo(dirIt.filePath()).isFile())
            {
                fileName = dirIt.fileName();
                if (Magus::isTypeBasedOnExtension(fileName, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS, Magus::MAGUS_SUPPORTED_IMAGE_FORMATS_LENGTH))
                {
                    fileName = textureFolder + QString("/") + fileName;
                    mTextureDockWidget->addTextureFile(fileName, GROUP_NAME_IMPORTED_TEXTURES); // Add it to a group
                }
            }
        }

        handleTextureMutationOccured();
    }
}

//****************************************************************************/
void MainWindow::doTextureBrowserAddImageMenuAction(void)
{
    QString fileName;
    QStringList fileNames;
    fileNames = QFileDialog::getOpenFileNames(this,
                                             QString("Select texture/image file(s)"),
                                             QString(""),
                                             QString("JPEG (*.jpg *.jpeg);;"
                                                     "PNG (*.png);;"
                                                     "DDS (*.dds);;"
                                                     "All files (*.*)"));
    foreach (fileName, fileNames)
    {
        if (!fileName.isEmpty())
            mTextureDockWidget->addTextureFile(fileName);
    }

    handleTextureMutationOccured();
}

//****************************************************************************/
void MainWindow::doResetWindowLayoutMenuAction(void)
{
    mRenderwindowDockWidget->show();
    addDockWidget(Qt::LeftDockWidgetArea, mRenderwindowDockWidget);
    mPropertiesDockWidget->show();
    addDockWidget(Qt::LeftDockWidgetArea, mPropertiesDockWidget);

    mTextureDockWidget->show();
    addDockWidget(Qt::RightDockWidgetArea, mTextureDockWidget);
    mNodeEditorDockWidget->show();
    addDockWidget(Qt::RightDockWidgetArea, mNodeEditorDockWidget);
}

//****************************************************************************/
void MainWindow::handleTextureDoubleClicked(const QString& fileName, const QString& baseName)
{
    if (Magus::fileExist(fileName))
    {
        mNodeEditorDockWidget->newSamplerblockNode(fileName);
    }
    else
    {
        QMessageBox::StandardButton reply = fileDoesNotExistsWarning(fileName);
        if (reply == QMessageBox::Yes)
        {
            mTextureDockWidget->deleteTexture(fileName);
        }
    }
}

//****************************************************************************/
void MainWindow::handleCustomContextMenuItemSelected(const QString& menuItemText)
{
    if (menuItemText == ACTION_IMPORT_TEXTURES_FROM_DIR)
        doTextureBrowserImportMenuAction();
    else if (menuItemText == ACTION_ADD_TEXTURES)
        doTextureBrowserAddImageMenuAction();
}

//****************************************************************************/
void MainWindow::handleTextureMutationOccured(void)
{
    // Do not save immediately, but only after some time; this is to prevent that saveTextureBrowserCfg
    // is called for every mutation in the texture tree (deletion of 100 textures in one go
    // triggers handleTextureMutationOccured also 100 times. We don't want to save 100 times).
    // This is the reason that a QTimer is used.
    if (mSaveTextureBrowserTimerActive)
        return;

    QTimer::singleShot(1000, this, SLOT(saveTextureBrowserCfg()));
    mSaveTextureBrowserTimerActive = true;
}

//****************************************************************************/
void MainWindow::saveTextureBrowserCfg(void)
{
    mSaveTextureBrowserTimerActive = false;
    const QVector<Magus::QtResourceInfo*>& resources = mTextureDockWidget->getResources();
    saveResources(mTextureFileName, resources);
}

//****************************************************************************/
void MainWindow::loadTextureBrowserCfg(void)
{
    QVector<Magus::QtResourceInfo*> resources;
    QFile file(mTextureFileName);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        Magus::QtResourceInfo* info;
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            QStringList elements = line.split('\t', QString::SkipEmptyParts);

            if (elements.size() == 6)
            {
                info = new Magus::QtResourceInfo();
                info->topLevelId = QVariant(elements[0]).toInt();
                info->parentId = QVariant(elements[1]).toInt();
                info->resourceId = QVariant(elements[2]).toInt();
                info->resourceType = QVariant(elements[3]).toInt();
                info->resourceName = elements[4];
                info->fullQualifiedName = elements[5];

                if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                        info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP)
                    info->iconName = ICON_TEXTURE_NO_PATH;
                else if (info->topLevelId == TOOL_SOURCES_LEVEL_X000_TEXTURE &&
                         info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_GROUP)
                    info->iconName = ICON_TEXTURE_SMALL_NO_PATH;

                resources.append(info);
            }
        }

        // In case the file is empty or contains garbage, add toplevel item
        if (resources.size() == 0)
        {
             info = new QtResourceInfo();
             info->topLevelId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->parentId = 0;
             info->resourceId = TOOL_SOURCES_LEVEL_X000_TEXTURE;
             info->resourceName = QString("Textures");
             info->fullQualifiedName = QString("Textures");
             info->resourceType = TOOL_RESOURCETREE_KEY_TYPE_TOPLEVEL_GROUP;
             info->iconName = ICON_TEXTURE_NO_PATH;
             resources.append(info);
        }

        // Set the resources
        mTextureDockWidget->setResources(resources);
        file.close();
    }
}

//****************************************************************************/
void MainWindow::saveResources(const QString& fileName, const QVector<Magus::QtResourceInfo*>& resources)
{
    // Save state of a resoruces from a resourcetree widget
    QFile file(fileName);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        QVectorIterator<Magus::QtResourceInfo*> it(resources);
        it.toFront();
        Magus::QtResourceInfo* info;
        while (it.hasNext())
        {
            // Write a line to the cfg file
            info = it.next();
            stream << info->topLevelId
                   << "\t"
                   << info->parentId
                   << "\t"
                   << info->resourceId
                   << "\t"
                   << info->resourceType
                   << "\t"
                   << info->resourceName
                   << "\t"
                   << info->fullQualifiedName
                   << "\n";
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::update(void)
{
    if (mOgreManager)
        mOgreManager->renderOgreWidgetsOneFrame();

    if (mFirst)
    {
        // Only do this once, otherwise it is not possible to change the widget manually (by means of keyboard)
        mRenderwindowDockWidget->updateTransformationWidgetFromOgreWidget();
        mFirst = false;
    }
}

//****************************************************************************/
void MainWindow::initDatablocks(void)
{
    destroyAllDatablocks();
    mHlmsName = QString("");
}

//****************************************************************************/
EditorHlmsTypes MainWindow::getCurrentDatablockType(void)
{
    return mNodeEditorDockWidget->getCurrentDatablockType();
}

//****************************************************************************/
QMessageBox::StandardButton MainWindow::fileDoesNotExistsWarning(const QString& fileName)
{
    return QMessageBox::question(0,
                                 "Warning",
                                 fileName + QString(" does not exist. Remove it from the texture browser?"),
                                 QMessageBox::Yes|QMessageBox::No);
}

//****************************************************************************/
void MainWindow::doImport(Ogre::HlmsEditorPlugin* plugin)
{
    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before import (to select the file to be imported)?
    if (plugin->isOpenFileDialogForImport())
    {
        QString fileName;
        fileName = QFileDialog::getOpenFileName(this, QString("Import"),
                                                QString(""),
                                                QString("(*.*)"));

        if (!fileName.isEmpty())
        {
            QFileInfo info(fileName);
            data.mInFileDialogName = info.fileName().toStdString();
            data.mInFileDialogPath = (info.absolutePath() + QString("/")).toStdString();
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No file selected"));
            return;
        }
    }

    // Execute the import
    QApplication::setOverrideCursor(Qt::WaitCursor);
    Ogre::HlmsDatablock* oldDatablock = data.mInOutCurrentDatablock;
    Ogre::HlmsDatablock* newDatablock;
    bool result = plugin->executeImport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        // Check whether a new datablock was created
        newDatablock = data.mInOutCurrentDatablock;
        if (newDatablock && oldDatablock != newDatablock)
        {
            // The pointer was changed (and not 0), so the assumption is that it points to a new datablock
            getAndSetFirstDatablock();
        }
        text = data.mOutSuccessText.c_str();
        if (text.isEmpty())
            text = QString ("Import completed");
        QMessageBox::information(0, QString("Info"), text);
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while importing");
        QMessageBox::information(0, QString("Error"), text);
    }
}

//****************************************************************************/
void MainWindow::doExport(Ogre::HlmsEditorPlugin* plugin)
{
    Ogre::HlmsEditorPluginData data;
    QString text;
    constructHlmsEditorPluginData(&data);

    // Is a filedialog needed before export (to select the dir to be exported)?
    if (plugin->isOpenFileDialogForExport())
    {
        QString textureFolder;
        QFileDialog dialog;
        dialog.setFileMode(QFileDialog::Directory);
        if (dialog.exec())
        {
            QStringList fileNames = dialog.selectedFiles();
            textureFolder = fileNames.at(0);
        }

        if (!textureFolder.isEmpty())
        {
            data.mInFileDialogPath = (textureFolder + QString("/")).toStdString();
        }
        else
        {
            QMessageBox::information(0, QString("Error"), QString("No directory"));
            return;
        }
    }

    QApplication::setOverrideCursor(Qt::WaitCursor);

    // Are the textures of all datablocks in the material browser needed?
    if (plugin->isTexturesUsedByDatablocksForExport())
    {
        // Load all datablocks from the material browser
        std::vector<Ogre::String> materials;
        materials = data.mInMaterialFileNameVector;
        std::vector<Ogre::String>::iterator it = materials.begin();
        std::vector<Ogre::String>::iterator itEnd = materials.end();
        Ogre::String fileName;
        while (it != itEnd)
        {
            // Load the materials
            fileName = *it;
            if (!fileName.empty())
            {
                loadDatablock(fileName.c_str());
            }
            ++it;
        }

        // Get the texture basenames from the datablocks
        std::vector<Ogre::String> vPbs;
        std::vector<Ogre::String> vUnlit;
        HlmsPbsBuilder pbsBuilder(0); // Do not pass the node editor (not needed in this case)
        HlmsUnlitBuilder unlitBuilder(0); // Do not pass the node editor (not needed in this case)
        pbsBuilder.getTexturesFromAvailableDatablocks (mOgreManager, &vPbs);
        unlitBuilder.getTexturesFromAvailableDatablocks (mOgreManager, &vUnlit);

        // Add all textures from Pbs
        std::vector<Ogre::String>::iterator itPbs = vPbs.begin();
        std::vector<Ogre::String>::iterator itPbsEnd = vPbs.end();
        Ogre::String baseName;
        while (itPbs != itPbsEnd)
        {
            baseName = *itPbs;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itPbs;
        }

        // Add all textures from Unlit
        std::vector<Ogre::String>::iterator itUnlit = vUnlit.begin();
        std::vector<Ogre::String>::iterator itUnlitEnd = vUnlit.end();
        while (itUnlit != itUnlitEnd)
        {
            baseName = *itUnlit;
            data.mInTexturesUsedByDatablocks.push_back(baseName);
            ++itUnlit;
        }
    }

    // Execute the export
    bool result = plugin->executeExport(&data);
    QApplication::restoreOverrideCursor();
    if (result)
    {
        text = data.mOutSuccessText.c_str();
        if (text.isEmpty())
            text = QString ("Export completed");
        QMessageBox::information(0, QString("Info"), text);
    }
    else
    {
        text = data.mOutErrorText.c_str();
        if (text.isEmpty())
            text = QString ("Error while exporting");
        QMessageBox::information(0, QString("Error"), text);
    }
}

//****************************************************************************/
void MainWindow::constructHlmsEditorPluginData(Ogre::HlmsEditorPluginData* data)
{
    QOgreWidget* widget = mOgreManager->getOgreWidget(OGRE_WIDGET_RENDERWINDOW);
    Ogre::Item* item = widget->getItem();
    data->mInItem = item;

    // mInMaterialFileNameVector
    data->mInMaterialFileName = mMaterialFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& materialResources = mMaterialBrowser->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itMaterials(materialResources);
    itMaterials.toFront();
    Magus::QtResourceInfo* info;
    data->mInMaterialFileNameVector.clear();
    while (itMaterials.hasNext())
    {
        // Only add real filenames (assets)
        info = itMaterials.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInMaterialFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    // mInTextureFileNameVector
    data->mInTextureFileName = mTextureFileName.toStdString();
    const QVector<Magus::QtResourceInfo*>& textureResources = mTextureDockWidget->getResources();
    QVectorIterator<Magus::QtResourceInfo*> itTextures(textureResources);
    itTextures.toFront();
    data->mInTextureFileNameVector.clear();
    while (itTextures.hasNext())
    {
        // Only add real filenames (assets)
        info = itTextures.next();
        if (info->resourceType == TOOL_RESOURCETREE_KEY_TYPE_ASSET)
            data->mInTextureFileNameVector.push_back(info->fullQualifiedName.toStdString());
    }

    data->mInOutCurrentDatablock = item->getSubItem(0)->getDatablock();
    data->mInProjectName = mProjectName.toStdString();
    data->mInProjectPath = mProjectPath.toStdString();
    data->mInFileDialogName = "";
    data->mInFileDialogPath = "";
    data->mInRenderWindow = widget->getRenderWindow();
    data->mInSceneManager = widget->getSceneManager();
    data->mInTextureFileName = mTextureFileName.toStdString();
    data->mOutErrorText = "Error while performing this function";
    data->mOutExportReference = "";
    data->mOutSuccessText = "";
    data->mInTexturesUsedByDatablocks.clear();
}

//****************************************************************************/
void MainWindow::appendRecentHlms(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentHlmsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentHlmsFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentHlmsFiles.size() > MAX_RECENT_HLMS_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentHlmsFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentHlmsFilesMenu->removeAction(action);
        delete action;
        mRecentHlmsFiles.removeAt(0);
    }

    mRecentHlmsFiles.append(recentFiles);
    mRecentHlmsFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentHlmsFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentHlmsFilesCfg();
}

//****************************************************************************/
void MainWindow::appendRecentProject(const QString fileName)
{
    // Check on duplicate
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    while(it != itEnd)
    {
        rc = *it;
        if (rc.fileName == fileName)
            return;
        ++it;
    }

    // Add to the menu
    RecentFileStruct recentFiles;
    recentFiles.action = new RecentFileAction(fileName, this);
    recentFiles.fileName = fileName;
    if (mRecentProjectFiles.size() > MAX_RECENT_PROJECT_FILES)
    {
        // Remove oldest (= first) from menu
        RecentFileStruct firstEntry = mRecentProjectFiles.at(0);
        QAction* action = firstEntry.action;
        mRecentProjectFilesMenu->removeAction(action);
        delete action;
        mRecentProjectFiles.removeAt(0);
    }

    mRecentProjectFiles.append(recentFiles);
    mRecentProjectFilesMenu->addAction(recentFiles.action);
    connect(recentFiles.action, SIGNAL(recentFileActionTriggered(QString)), this, SLOT(doRecentProjectFileAction(QString)));

    // Save the recent list to a file (and load it at startup)
    saveRecentProjectFilesCfg();
}

//****************************************************************************/
void MainWindow::doRecentHlmsFileAction(const QString& fileName)
{
    loadDatablockAndSet(fileName);
}

//****************************************************************************/
void MainWindow::doRecentProjectFileAction(const QString& fileName)
{
    loadProject(fileName);
}

//****************************************************************************/
void MainWindow::loadRecentHlmsFilesCfg(void)
{
    QFile file(FILE_RECENT_HLMS_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentHlms(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentHlmsFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentHlmsFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentHlmsFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_HLMS_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::loadRecentProjectFilesCfg(void)
{
    QFile file(FILE_RECENT_PROJECT_FILES);
    QString line;
    if (file.open(QFile::ReadOnly))
    {
        QTextStream readFile(&file);
        while (!readFile.atEnd())
        {
            line = readFile.readLine();
            appendRecentProject(line);
        }
       file.close();
    }
}

//****************************************************************************/
void MainWindow::saveRecentProjectFilesCfg(void)
{
    QList<RecentFileStruct>::const_iterator it = mRecentProjectFiles.begin();
    QList<RecentFileStruct>::const_iterator itEnd = mRecentProjectFiles.end();
    RecentFileStruct rc;
    QFile file(FILE_RECENT_PROJECT_FILES);
    if (file.open(QFile::WriteOnly|QFile::Truncate))
    {
        QTextStream stream(&file);
        while(it != itEnd)
        {
            rc = *it;
            stream << rc.fileName
                   << "\n";
            ++it;
        }
        file.close();
    }
}

//****************************************************************************/
void MainWindow::doMaterialBrowserAccepted(const QString& fileName)
{
    // A change is made in the material browser and accepted with ok or double click on an item
    if (!fileName.isEmpty())
        loadDatablockAndSet(fileName);

    // Save all current settings
    saveMaterialBrowserCfg();
}

//****************************************************************************/
void MainWindow::doMaterialBrowserRejected(void)
{
    loadMaterialBrowserCfg(); // Reverses all changes
}

//****************************************************************************/
void MainWindow::doMaterialBrowserClosed(void)
{
    mMaterialBrowserPosition = mMaterialBrowser->pos();
    mMaterialBrowserSize = mMaterialBrowser->size();
}
