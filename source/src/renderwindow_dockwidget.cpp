/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include "constants.h"
#include "mainwindow.h"
#include "OgreMeshManager2.h"
#include "Renderwindow_dockwidget.h"

//****************************************************************************/
RenderwindowDockWidget::RenderwindowDockWidget(QString title, MainWindow* parent, Qt::WindowFlags flags) : 
	QDockWidget (title, parent, flags), 
    mParent(parent),
    mButtonToggleModelAndLight(0),
    mButtonMarker(0),
    mButtonToggleHoover(0),
    mButtonModelActive(true),
    mToggleHooverOn(false),
    mLightIcon(0),
    mModelIcon(0),
    mMarkerIcon(0),
    mHooverOnIcon(0),
    mHooverOffIcon(0)
{
    // Create the meshMap
    QFile file(QString("models.cfg"));
    file.open(QFile::ReadOnly | QFile::Text);
    QTextStream readFile(&file);
    MeshStruct meshStruct;
    QString line;
    QString key;
    QString x;
    QString y;
    QString z;
    while (!readFile.atEnd())
    {
        line = readFile.readLine();
        QStringList elements = line.split(' ', QString::SkipEmptyParts);
        if (elements.size() == 5)
        {
            // Only 5 items
            key = elements[0];
            meshStruct.meshName = elements[1];
            x = elements[2];
            y = elements[3];
            z = elements[4];
            QVector3D scale(x.toFloat(), y.toFloat(), z.toFloat());
            meshStruct.scale = scale;
            mMeshMap.insert(key, meshStruct);
        }
    }

    mInnerMain = new QMainWindow();
    setWidget(mInnerMain);

    // Perform standard functions
    createActions();
    createMenus();
    createToolBars();

    mOgreWidget = new Magus::QOgreWidget();
    mInnerMain->setCentralWidget(mOgreWidget);
    parent->getOgreManager()->registerOgreWidget(OGRE_WIDGET_RENDERWINDOW, mOgreWidget);
    mOgreWidget->createRenderWindow(parent->getOgreManager());

    // Set the max. width of the renderwindow
    QRect rec = QApplication::desktop()->screenGeometry();
    setMaximumWidth(1.78 * rec.height()); // 1.78 = 16/9

    // Load the list with meshes
    preLoadMeshMap();

    mOgreWidget->setFocus();
}

//****************************************************************************/
RenderwindowDockWidget::~RenderwindowDockWidget(void)
{
}

//-------------------------------------------------------------------------------------
void RenderwindowDockWidget::resizeEvent(QResizeEvent *e)
{
    // The heigth of the renderwindow follows the width, because the renderwindow must alway be
    // square; this is because the render-texture for picking and highlighting is square
    // Note, that this setup makes manual resizing of the height impossible
    if(e->isAccepted())
    {
        setMinimumHeight(0.5625 * e->size().width()); // 0.5625 = 9/16
        setMaximumHeight(0.5625 * e->size().width());
    }
}

//****************************************************************************/
void RenderwindowDockWidget::addToMeshMap(const QString name,
                                          const QString meshName,
                                          QVector3D scale)
{
    MeshStruct meshStruct;
    meshStruct.meshName = meshName;
    meshStruct.scale = scale;
    mMeshMap.insert(name, meshStruct);
    QAction* item = new QAction(name, this);
    mMeshMenu->addAction(item);
}

//****************************************************************************/
void RenderwindowDockWidget::preLoadMeshMap(void)
{
    Ogre::String meshName;
    QMap<QString, MeshStruct>::iterator it;
    QMap<QString, MeshStruct>::iterator itStart = mMeshMap.begin();
    QMap<QString, MeshStruct>::iterator itEnd = mMeshMap.end();
    for (it = itStart; it != itEnd; ++it)
    {
        meshName = it.value().meshName.toStdString();
        Ogre::MeshPtr v2MeshPtr = Ogre::MeshManager::getSingleton().load(
                    meshName, Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);
    }
}

//****************************************************************************/
void RenderwindowDockWidget::createActions(void)
{
    mChangeBackgroundAction = new QAction(QIcon(ICON_COLOUR), QString("Change background colour"), this);
    connect(mChangeBackgroundAction, SIGNAL(triggered()), this, SLOT(doChangeBackgroundAction()));
}

//****************************************************************************/
void RenderwindowDockWidget::createMenus(void)
{
    QAction* item;
    QMenuBar* menuBar = mInnerMain->menuBar();
    mMeshMenu = menuBar->addMenu(QString("Change mesh"));

    QMap<QString, MeshStruct>::iterator it;
    QMap<QString, MeshStruct>::iterator itStart = mMeshMap.begin();
    QMap<QString, MeshStruct>::iterator itEnd = mMeshMap.end();
    for (it = itStart; it != itEnd; ++it)
    {
        item = new QAction(it.key(), this);
        mMeshMenu->addAction(item);
    }
    connect(mMeshMenu, SIGNAL(triggered(QAction*)), this, SLOT(doChangeItemAction(QAction*)));
}

//****************************************************************************/
void RenderwindowDockWidget::createToolBars(void)
{
    // Toolbar
    mHToolBar = new QToolBar();

    // Button to switch between model and light movement/rotation
    mButtonToggleModelAndLight = new QPushButton();
    mButtonMarker = new QPushButton();
    mButtonToggleHoover = new QPushButton();
    mModelIcon = new QIcon(ICON_MODEL);
    mLightIcon = new QIcon(ICON_LIGHT);
    mMarkerIcon = new QIcon(ICON_MARKER);
    mHooverOnIcon = new QIcon(ICON_HOOVER_ON);
    mHooverOffIcon = new QIcon(ICON_HOOVER_OFF);
    mButtonToggleModelAndLight->setIcon(*mModelIcon);
    mButtonMarker->setIcon(*mMarkerIcon);
    mButtonToggleHoover->setIcon(*mHooverOffIcon);
    connect(mButtonToggleModelAndLight, SIGNAL(clicked(bool)), this, SLOT(handleToggleModelAndLight()));
    connect(mButtonMarker, SIGNAL(clicked(bool)), this, SLOT(handleMarker()));
    connect(mButtonToggleHoover, SIGNAL(clicked(bool)), this, SLOT(handleToggleHoover()));

    // Transformation widget
    mTransformationWidget = new Magus::TransformationWidget(mHToolBar);
    mTransformationWidget->setMaximumWidth(344);
    mTransformationWidget->setCurrentIndex(2); // Only scale is visible
    mTransformationWidget->setListEnabled(false);
    mInnerMain->addToolBar(Qt::TopToolBarArea, mHToolBar);
    mHToolBar->setMinimumHeight(32);
    //mHToolBar->setMinimumWidth(8 * 32);
    QWidget* spacer = new QWidget();
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    // Add widgets
    mHToolBar->addWidget(mTransformationWidget);
    mHToolBar->addWidget(mButtonToggleModelAndLight);
    mHToolBar->addWidget(mButtonMarker);
    mHToolBar->addWidget(mButtonToggleHoover);
    mHToolBar->addWidget(spacer);
    mHToolBar->addAction(mChangeBackgroundAction);
    connect(mTransformationWidget, SIGNAL(valueChanged()), this, SLOT(doTransformationWidgetValueChanged()));
}

//****************************************************************************/
void RenderwindowDockWidget::doChangeItemAction(QAction* action)
{
    QMap<QString, MeshStruct>::iterator it;
    QMap<QString, MeshStruct>::iterator itStart = mMeshMap.begin();
    QMap<QString, MeshStruct>::iterator itEnd = mMeshMap.end();
    MeshStruct meshStruct;
    for (it = itStart; it != itEnd; ++it)
    {
        if (action->text() == it.key())
        {
            meshStruct = it.value();
            Ogre::Vector3 scale(meshStruct.scale.x(),
                                meshStruct.scale.y(),
                                meshStruct.scale.z());
            Ogre::String meshName = meshStruct.meshName.toStdString();
            mOgreWidget->createItem(meshName, scale);
            updateTransformationWidgetFromOgreWidget();
        }
    }
}

//****************************************************************************/
void RenderwindowDockWidget::handleToggleModelAndLight(void)
{
    if (mButtonModelActive)
    {
        // Enable Light axis
        mButtonToggleModelAndLight->setIcon(*mLightIcon);
        mOgreWidget->enableLightItem(true);
    }
    else
    {
        // Disable Light axis
        mButtonToggleModelAndLight->setIcon(*mModelIcon);
        mOgreWidget->enableLightItem(false);
    }
    mButtonModelActive = !mButtonModelActive;
}

//****************************************************************************/
void RenderwindowDockWidget::handleMarker(void)
{
    mOgreWidget->resetCamera();
}

//****************************************************************************/
void RenderwindowDockWidget::handleToggleHoover(void)
{
    if (mToggleHooverOn)
        mButtonToggleHoover->setIcon(*mHooverOffIcon);
    else
        mButtonToggleHoover->setIcon(*mHooverOnIcon);
    mToggleHooverOn = !mToggleHooverOn;
    mOgreWidget->setHoover(mToggleHooverOn);
}

//****************************************************************************/
void RenderwindowDockWidget::updateTransformationWidgetFromOgreWidget(void)
{
    if (!mOgreWidget)
        return;

    QVector3D v;

    // Scale
    v.setX(mOgreWidget->getItemScale().x);
    v.setY(mOgreWidget->getItemScale().y);
    v.setZ(mOgreWidget->getItemScale().z);
    mTransformationWidget->setScale(v);
}

//****************************************************************************/
void RenderwindowDockWidget::doTransformationWidgetValueChanged(void)
{
    if (!mOgreWidget)
        return;

    // Replace the code in this function with your own code.
    switch (mTransformationWidget->getCurrentTransformation())
    {
        case Magus::TransformationWidget::SCALE:
        {
            Ogre::Vector3 v;
            v.x = mTransformationWidget->getScale().x();
            v.y = mTransformationWidget->getScale().y();
            v.z = mTransformationWidget->getScale().z();
            mOgreWidget->setItemScale(v);
        }
        break;
    }
}

//****************************************************************************/
void RenderwindowDockWidget::doChangeBackgroundAction(void)
{
    QColorDialog dialog;
    QColor c = dialog.getColor();
    Ogre::ColourValue colour(c.red()/255.0f, c.green()/255.0f, c.blue()/255.0f, 1.0f);
    mOgreWidget->setBackgroundColour(colour);
}
